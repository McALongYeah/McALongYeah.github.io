<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2024/04/01/RabbitMQ/"/>
      <url>/2024/04/01/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ?"></a>什么是RabbitMQ?</h2><blockquote><p>高性能的异步通信组件</p><p>时效性差，并发性能高</p></blockquote><h2 id="同步异步调用"><a href="#同步异步调用" class="headerlink" title="同步异步调用"></a>同步异步调用</h2><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><blockquote><p>同步调用的优势：</p><p>时效性强，等待到结果后才返回</p><p>问题：</p><p>拓展性差</p><p>性能下降</p><p>级联失败问题</p></blockquote><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><blockquote><p>异步调用的三个角色</p><p>消息发送者：投递消息的人，调用方</p><p>消息代理：管理、暂存、转发消息</p><p>消息接收者： 接受消息的人，服务提供方</p><p>优势：</p><p>解除耦合，拓展性强</p><p>无需等待，性能好</p><p>故障隔离</p><p>缓存消息，流量削峰填谷</p><p>问题：</p><p>不能及时得到调用结果，时效性差</p><p>不能确定下游业务是否成功</p><p>业务安全完全依赖于消息代理（Broker）的可靠性</p></blockquote><h2 id="RabbitMQ开始"><a href="#RabbitMQ开始" class="headerlink" title="RabbitMQ开始"></a>RabbitMQ开始</h2><h3 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h3><p>Docker镜像拉取</p><blockquote><p>docker pull rabbitmq</p></blockquote><p>部署</p><blockquote><p>docker run -d –name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq</p></blockquote><blockquote><p>创建用户</p><p>rabbitmqctl add_user admin your_password</p></blockquote><blockquote><p>如果拉取镜像部署完，并且端口已开放，还是无法访问，这说明RabbitMQ管理插件未启用，进入容器后，输入rabbitmq-plugins enable rabbitmq_management 即可</p></blockquote><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><blockquote><p>publisher:消息发送者</p><p>consumer:消息的消费者</p><p>queue:队列，存储消息</p><p>exchange:交换机，负责路由、转发消息，没有存储消息的能力</p><p>virtual-host:虚拟主机，起到数据隔离的作用</p></blockquote><p><img src="/img/rabbitmq/gainian.png"></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><blockquote><p>在RabbitMQ控制台完成下列操作:</p><p>新建队列hello.queue1和queue2</p><p>向默认的amp.fanout交换机发送一条消息</p><p>查看消息是否到达hello.queue1和hello.queue2</p></blockquote><p><strong>新建两个队列</strong></p><p><img src="/img/rabbitmq/add1.png"></p><p><strong>交换机绑定两个队列，并向其发送消息</strong></p><p><img src="/img/rabbitmq/send.png"></p><p><strong>队列接受到消息</strong></p><p><img src="/img/rabbitmq/get.png"></p><h3 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h3><blockquote><p>在rabbitmq控制台新建一个用户，给他admin权限，并为其创建一个虚拟主机，他只具有查看其它消息队列及其其它信息的权限，不能对别的用户的数据进行干涉，不同的虚拟主机之间出现数据隔离的现象。</p></blockquote><p><img src="/img/rabbitmq/geli.png"></p><h2 id="JAVA客户端的使用"><a href="#JAVA客户端的使用" class="headerlink" title="JAVA客户端的使用"></a>JAVA客户端的使用</h2><h3 id="AMQP和Spring-AMQP"><a href="#AMQP和Spring-AMQP" class="headerlink" title="AMQP和Spring AMQP"></a>AMQP和Spring AMQP</h3><blockquote><p>AMQP:</p><p>Advanced Message Queuing Protocol,用于应用程序之间传递业务消息的开放标准协议。语言无关性-符合微服务中的独立性要求。</p><p>Spring AMQP:</p><p>基于AMQP的一套API规范，提供发送和接受消息的模板。</p><p>其中，Spring-AMQP是基础抽象，Spring-Rabbit是底层的默认实现。</p></blockquote><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SpringAMQP收发消息</p><blockquote><p>1.引入spring-boot-starter-amqp依赖</p><p>2.配置RabbitMQ服务端消息</p><p>3.利用RabbitTemplate发送消息</p><p>4.利用@RabbitListener注解声明要监听的队列，监听消息</p></blockquote><blockquote><p>用一个项目简单描述rabbitMQ消息的收发过程,再rabbitMQ的网页端注册一个hmall的用户，新建一个simple.queue的消息队列，用于模拟publisher消息发送端发送消息到simple.queue,由消息队列转发消息到consumer，consumer监听pulisher所发送的消息。</p></blockquote><p><img src="/img/rabbitmq/newqueue.png"></p><p><strong>1.引入依赖</strong></p><blockquote><p>这里依赖是父项目中的，publisher与comsumer是两个子项目</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.配置RabbitMQ服务端</strong></p><blockquote><p>publisher发送消息端的yml配置</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><p><strong>3.利用RabbitTemplate发送消息</strong></p><blockquote><p>写一个publisher端的测试类，用于模拟发送消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@SpringBootTest</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PublisherApplicationTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSendMessage2Queue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello,rabbit!&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName,msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.配置consumer端的配置文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p><strong>5.消息接收</strong></p><blockquote><p>利用RabbitListener来声明要监听的队列信息<br>将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。 可以看到方法体中接收的就是消息体的内容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mlsq</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到的消息为：&quot;</span>+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.测试</p><blockquote><p>在启动consumer之前执行publisher的测试方法观察rabbitMQ网页端可看见未转发前的队列消息，但是当启动consumer类后再次执行测试方法则无法观察到网页端的消息，因为此时消息已经被消息队列转发到conumer端</p></blockquote><p><img src="/img/rabbitmq/cg1.png"></p><p><img src="/img/rabbitmq/cg2.png"></p><blockquote><p>启动consumer启动类，执行publisher的测试方法，验证可行性</p></blockquote><p><img src="/img/rabbitmq/chengg.png"></p><blockquote><p>成功consumer监听到了来自simple.queue的转发的消息，并执行了监听的方法</p></blockquote><h2 id="work-queue"><a href="#work-queue" class="headerlink" title="work queue"></a>work queue</h2><h3 id="work模型（解决消息堆积问题）"><a href="#work模型（解决消息堆积问题）" class="headerlink" title="work模型（解决消息堆积问题）"></a>work模型（解决消息堆积问题）</h3><p><img src="/img/rabbitmq/workqueue.png"></p><blockquote><p>多个消费者绑定到一个队列，可以加快消息处理速度</p><p>同一条消息只会被一个消费者处理</p><p>通过设置prefetch来控制消费者预取的消息数量，处理完一条消息再处理下一条，实现能者多劳</p></blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote><p>在rabbitMQ控制台创建一个队列，名为work.queue</p><p>在publisher服务中定义测试方法，在1s内产生50条消息，发送到work.queue</p><p>在consumer服务中定义两个消息监听者，都监听work.queue队列</p><p>消费者1每秒处理50条消息，消费者2每秒处理5条消息</p></blockquote><p><strong>消息发送者发送50条消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;work.queue&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello,workQueue!,msg:&quot;</span> + i;</span><br><span class="line">           rabbitTemplate.convertAndSend(queueName,msg);</span><br><span class="line">           Thread.sleep(<span class="number">20</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>接收端接受消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lwq1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;c1收到的消息为：&quot;</span>+ msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lwq2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;c2收到的消息为....：&quot;</span>+ msg);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>接受消息的方式按照轮询的方式分配给消费者</p></blockquote><p><img src="/img/rabbitmq/wk2.png"></p><p><strong>当消费者性能不一致时</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lwq1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;c1收到的消息为：&quot;</span>+ msg);</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lwq2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;c2收到的消息为....：&quot;</span>+ msg);</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/rabbitmq/dui.png"></p><blockquote><p>还是按照轮询的方式进行分配，并且出现了消息堆积的现象，性能高的消费者优先完成，性能差者消息堆积</p></blockquote><p><strong>解决办法</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/img/rabbitmq/lao.png"></p><blockquote><p>加入prefetch，每次必须完成一条消息后才可以进行下次消息处理，性能更强的消费者分配的消息更多，能者多劳</p></blockquote><h2 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h2><h3 id="fanout交换机"><a href="#fanout交换机" class="headerlink" title="fanout交换机"></a>fanout交换机</h3><blockquote><p>真实的生产环境都会经过exchange来发送消息，额不是直接发送到队列</p><p>交换机的类型有以下三种</p><p>Fanout：广播</p><p>Direct：定向</p><p>Topic：话题</p><p>作用：</p><p>接受publisher发送的消息</p><p>将消息按照规则路由到与之绑定的队列</p><p>FanoutExchange会将消息路由到每个绑定的队列</p></blockquote><blockquote><p>Fanout Exchange会将接受到的消息广播到每一个跟其绑定的queue,所以也叫广播模式</p></blockquote><p><img src="/img/rabbitmq/exchange.png"></p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a><strong>案例</strong></h3><p><img src="/img/rabbitmq/fx.png"></p><p><strong>consumer服务中的两个消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lft1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;c1收到的f1消息为：&quot;</span>+ msg);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lft2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       System.err.println(<span class="string">&quot;c2收到的f2消息为....：&quot;</span>+ msg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>向交换机发送消息并广播</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">testSendFanout</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>;</span><br><span class="line">          <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello,fanout!&quot;</span>;</span><br><span class="line">          rabbitTemplate.convertAndSend(exchange,<span class="literal">null</span>,msg);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>与交换机绑定的消息队列，都收到了由fanout交换机广播到的消息并转发给对应的消费者</p></blockquote><p><img src="/img/rabbitmq/wc.png"></p><h2 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h2><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-分布式锁</title>
      <link href="/2024/03/30/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2024/03/30/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket</title>
      <link href="/2023/12/27/WebSocket/"/>
      <url>/2023/12/27/WebSocket/</url>
      
        <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote><p>WebSocket Protocol一种新的HTML5协议,实现了浏览器与服务器(B&#x2F;S架构)全双工通信,一开始的握手(建立连接，长连接)需要借助HTTP请求完成。</p><p>全双工通信: 同时双向传输数据(A-&gt;B,B-&gt;A),瞬时同步</p><p>WebSocket: 真正实现全双工通信的服务器向客户端推的互联网技术。原理类似广播播音</p><p>WebSocket协议使用较少的开销来维持连接，相对于传统的Socket，它不需要频繁地建立和关闭连接，减少了服务器的负担</p></blockquote><blockquote><p>@OnOpen 成功建立连接调用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WebSocket </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GateWay-网关</title>
      <link href="/2023/12/17/GateWay-%E7%BD%91%E5%85%B3/"/>
      <url>/2023/12/17/GateWay-%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="GateWay"><a href="#GateWay" class="headerlink" title="GateWay"></a>GateWay</h2><h3 id="什么是GateWay"><a href="#什么是GateWay" class="headerlink" title="什么是GateWay"></a>什么是GateWay</h3><blockquote><p>基于Spring 5.0 、SpringBoot 2.0和Project Reactor开发的高性能API网关组件</p></blockquote><h3 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h3><blockquote><p>API网关是一个中间层，集中管理、保护和优化API请求与响的通信。</p><p>API 网关提供了安全、流控、过滤、缓存、计费以及监控等 API 管理功能，使得系统更易于管理、更安全、更高效，并提供了更好的可视化和分析能力。</p></blockquote><h3 id="GateWay的主要概念"><a href="#GateWay的主要概念" class="headerlink" title="GateWay的主要概念"></a>GateWay的主要概念</h3><blockquote><p>Route(路由) : 由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成</p><p>1.地址映射转发：</p><p>http:&#x2F;&#x2F;网关ip:网关端口&#x2F;服务名映射&#x2F;xxxx?xxx&#x3D;x</p><p>2.服务名映射&#x2F;xxxx?xxx&#x3D;x 转换成对应的微服务的请求地址,再把请求发出</p><p>Predicate（断言）: 对 HTTP 请求进行匹配 -&gt; 判读用哪一条路由</p><p>Filter（过滤器）: 对请求进行拦截和修改 -&gt; 插件机制 ,责任链模式组装，aop增强机制</p></blockquote><h2 id="GateWay开始"><a href="#GateWay开始" class="headerlink" title="GateWay开始"></a>GateWay开始</h2><h3 id="GateWay的搭建"><a href="#GateWay的搭建" class="headerlink" title="GateWay的搭建"></a>GateWay的搭建</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 利用actuator查看gateway 配置的理由路径（api形式）--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 将gateway注册到nacos上--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置yml文件"><a href="#配置yml文件" class="headerlink" title="配置yml文件"></a>配置yml文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">20001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">res-gateway</span></span><br><span class="line">    <span class="comment"># 将服务注册到nacos上</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br></pre></td></tr></table></figure><h4 id="写启动类"><a href="#写启动类" class="headerlink" title="写启动类"></a>写启动类</h4><blockquote><p>启动服务,将服务注册到nacos上，并在nacos的服务列表查看是否注册成功</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">gatewayApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(gatewayApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><blockquote><p>当我们访问<a href="http://localhost:20001时，请求会自动转发到百度的页面">http://localhost:20001时，请求会自动转发到百度的页面</a></p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span> <span class="comment">#基础的路由转发配置</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#查看配置源码  routes是一个有序的list集合 可以配置多个 读取顺序从上往下</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">res-good</span>   <span class="comment">#唯 一区别的名字</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:9200</span>   </span><br><span class="line"><span class="comment">#- Path符合localhost:20001/resfood 被替换   http://localhost:9200/resfood/findById/1 </span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/resfood/**</span> <span class="comment">#将resfood后面的内容替换 #http://localhost:20001/resfood/findById/1</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">baidu</span>   <span class="comment">#唯 一区别的名字</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span>    <span class="comment">#都转发到baidu  替换请求路径http://localhost:20001/ xx</span></span><br><span class="line">          <span class="attr">predicates:</span>   <span class="comment">#比较条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/**</span>  <span class="comment">#所有请求（通用配置） 路径断言</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="日志文件配置"><a href="#日志文件配置" class="headerlink" title="日志文件配置"></a>日志文件配置</h3><blockquote><p>启动类配置虚拟机参数,启用Reactor Netty HTTP服务器的访问日志</p><p>-Dreactor.netty.http.server.accessLogEnabled&#x3D;true</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置文件每隔1分钟，就检查更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ch.qos.logback.core.ConsoleAppender 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 过去使用layout，现在都推荐使用encoder</span></span><br><span class="line"><span class="comment">             作用一：将日志信息转换（格式化）为字符串</span></span><br><span class="line"><span class="comment">             作用二：然后写入到文件中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] [%-5level] %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志以文件形式保存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;accessLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志文件名称--&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>gateway_access_log.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志输出的格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志同步--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;async&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;accessLog&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 记录到文件中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;reactor.netty.http.server.AccessLog&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;async&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制台打印--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.yc&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 也是一种&lt;logger&gt;,是所有&lt;logger&gt;的父级 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 不设置additivity属性，或者设置additivity = true的&lt;logger&gt;,会继承root的子标签&lt;appender-ref ref=&quot;console&quot; /&gt;的设置，</span></span><br><span class="line"><span class="comment">        将它自己设置的level属性级别及以上的日志打印到控制台 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;root level=&quot;info&quot;&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &amp;lt;!&amp;ndash; 表示按照console的设置去输出日志到控制台 &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;appender-ref ref=&quot;console&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;/root&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><p><img src="/img/gateway/logger.png"></p><h3 id="GateWay负载均衡"><a href="#GateWay负载均衡" class="headerlink" title="GateWay负载均衡"></a>GateWay负载均衡</h3><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入riboon,客户端保存服务列表信息 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改application配置文件"><a href="#修改application配置文件" class="headerlink" title="修改application配置文件"></a>修改application配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span> <span class="comment">#基础的路由转发配置</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#查看配置源码  routes是一个有序的list集合 可以配置多个 读取顺序从上往下</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">res-good</span>   <span class="comment">#唯 一区别的名字</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://resfood</span> <span class="comment">#resfood服务名 -&gt; 利用loadBalancer保存的服务列表选一台服务器  （gateway与resfood服务在同一个命名空间下）</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/resfood/**</span> <span class="comment">#将resfood后面的内容替换 #http://localhost:20001/resfood/findById/1</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><blockquote><p>开启resfood服务,并启用多个端口,这里给该服务启动了9200 、9300两个端口用于负载均衡，重复访问两次<a href="http://localhost:20001/resfood/findById/1">localhost:20001&#x2F;resfood&#x2F;findById&#x2F;1</a>，查看负载均衡结果</p></blockquote><p><img src="/img/gateway/lb.png"></p><h3 id="actuator的路由操作"><a href="#actuator的路由操作" class="headerlink" title="actuator的路由操作"></a>actuator的路由操作</h3><h4 id="导入actuator的依赖"><a href="#导入actuator的依赖" class="headerlink" title="导入actuator的依赖"></a>导入actuator的依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="actuator配置文件的配置"><a href="#actuator配置文件的配置" class="headerlink" title="actuator配置文件的配置"></a>actuator配置文件的配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span>                                <span class="comment">#通过 actuator暴露此服务的管理端口</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span>                                   <span class="comment">#通过web来暴露管理API,</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>  <span class="comment">#显示所有的信息</span></span><br></pre></td></tr></table></figure><h4 id="对actuator路由的操作"><a href="#对actuator路由的操作" class="headerlink" title="对actuator路由的操作"></a>对actuator路由的操作</h4><p><img src="/img/gateway/actuator_routes.png"></p><h2 id="GateWay原理"><a href="#GateWay原理" class="headerlink" title="GateWay原理"></a>GateWay原理</h2><h3 id="谓词工厂-构造模式"><a href="#谓词工厂-构造模式" class="headerlink" title="谓词工厂-构造模式"></a>谓词工厂-构造模式</h3><blockquote><p>根据输入(条件)生成一个匹配规则对象，创建型的设计模式(例: 单例,构造器builder-流式方案创建,简单工厂,抽象工厂)</p><p>谓词 -&gt; 判断 </p><p>result: true&#x2F;false</p><p>输入数据: 一个&#x2F;多个</p><p>谓词接口:   -&gt;将if-else的判断转换成一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;!--<span class="number">1</span>--&gt;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&gt;<span class="comment">// 使用Predicate过滤集合</span></span><br><span class="line">       List&lt;String&gt; ns = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>);  <span class="comment">//创建 不可变集合</span></span><br><span class="line">       List&lt;String&gt; names=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;( ns );   <span class="comment">//转为可变集合，以便后面使用 removeIf删除元素</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 定义一个Predicate，判断字符串长度是否大于3</span></span><br><span class="line">       Predicate&lt;String&gt; lengthPredicate = s -&gt; s.length() &gt; <span class="number">3</span>;</span><br><span class="line">&gt;names.removeIf(lengthPredicate);</span><br><span class="line">&gt;System.out.println(names);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//removeIf底层</span></span><br><span class="line">&gt;<span class="comment">//names(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;)</span></span><br><span class="line">&gt;<span class="comment">//filter: s.length() &gt; 3</span></span><br><span class="line">&gt;<span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">   Objects.requireNonNull(filter);</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">//names数组的迭代</span></span><br><span class="line">   <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();、</span><br><span class="line">   <span class="comment">//迭代names数组里面的元素,看看是否满足移除的条件</span></span><br><span class="line">   <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">       <span class="comment">//判断 names是否满足filter过滤器的条件</span></span><br><span class="line">       <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">           <span class="comment">//移除满足条件names元素</span></span><br><span class="line">           each.remove();</span><br><span class="line">           <span class="comment">//判断是否删除成功</span></span><br><span class="line">           removed = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> removed;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//所以这里输出的结果为Bob</span></span><br><span class="line"></span><br><span class="line">&gt;&lt;!--<span class="number">2</span>--&gt;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//<span class="doctag">TODO:</span> Predicate&lt;T&gt; and 方法使用</span></span><br><span class="line">       List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">       Predicate&lt;Integer&gt; predicate1 = x -&gt; x &gt; <span class="number">3</span>;</span><br><span class="line">       Predicate&lt;Integer&gt; predicate2 = x -&gt; x &lt; <span class="number">9</span>;</span><br><span class="line">   <span class="comment">//底层实现 -&gt; 多个条件(断言)用and进行连接</span></span><br><span class="line">   <span class="comment">//流式调用builder的设计模式</span></span><br><span class="line">       List&lt;Integer&gt; collect = list.stream().filter(predicate1.and(predicate2)).collect(Collectors.toList());</span><br><span class="line">       System.out.println(collect);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//result 4,5,6,7,8</span></span><br><span class="line"></span><br><span class="line">&gt;&lt;!--<span class="number">3</span>--&gt;</span><br><span class="line">   <span class="comment">//多个参数</span></span><br><span class="line">&gt;<span class="comment">// 使用BiPredicate判断两个字符串是否相等</span></span><br><span class="line">       BiPredicate&lt;String, String&gt; equalPredicate = (s1, s2) -&gt; s1.equals(s2);</span><br><span class="line">       System.out.println(equalPredicate.test(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hello&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">       System.out.println(equalPredicate.test(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>resgateway</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt;spring:</span></span><br><span class="line">   <span class="attr">cloud:</span></span><br><span class="line">       <span class="attr">gateway:</span></span><br><span class="line">          <span class="attr">routes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">resIndex</span></span><br><span class="line">         <span class="attr">uri:</span> <span class="string">lb://resIndex</span></span><br><span class="line">         <span class="attr">predicates:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="string">Path=/**</span></span><br></pre></td></tr></table></figure><p>html的路径中</p><p>resfood&#x2F;findByPage?pageno&#x3D;1&amp;pagesize&#x3D;5是相对路径</p><p>访问浏览器index.html <a href="http://localhost:2001/index.html">http://localhost:2001/index.html</a></p><p>相对于浏览器的地址</p><p>gateway                            &#x2F;resfood&#x2F;**        </p><p><a href="http://localhost:2001/">http://localhost:2001/</a>   resfood&#x2F;findByPage?pageno&#x3D;1&amp;pagesize&#x3D;5</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringCloud与微服务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务哨兵-sentinel</title>
      <link href="/2023/12/02/%E6%9C%8D%E5%8A%A1%E5%93%A8%E5%85%B5-sentinel/"/>
      <url>/2023/12/02/%E6%9C%8D%E5%8A%A1%E5%93%A8%E5%85%B5-sentinel/</url>
      
        <content type="html"><![CDATA[<h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><h3 id="什么是服务雪崩"><a href="#什么是服务雪崩" class="headerlink" title="什么是服务雪崩?"></a>什么是服务雪崩?</h3><blockquote><p>服务雪崩是一种因”服务提供者的不可用”导致”服务调用者不可用”,并将不可用逐渐放大的现象</p></blockquote><p><img src="/img/sentinel/xuebeng.png"></p><h3 id="雪崩的原因及三个阶段"><a href="#雪崩的原因及三个阶段" class="headerlink" title="雪崩的原因及三个阶段"></a>雪崩的原因及三个阶段</h3><blockquote><p>阶段一:  服务不可用</p><p>​  – 硬件故障</p><p>​  – 程序BUG</p><p>​  – 缓存击穿 -&gt; 例如一个程序是通过id号查询其详细信息,我们利用redis缓存保存一些热点信息,当一个查询的id不在缓存内时,会转向数据库查询这些数据,每次访问这些数据都会直接去查询数据库里面的信息</p><p>​ – 用户的大量请求 </p><p>阶段二: 调用端的重试加大流量（例: openfeign的底层使用了重试器,当用户发送请求时,发生了网络抖动,导致请求无法在规定的时间的时间内拿到数据,这时重试器会再次发送这个请求,再次对数据进行拉去）</p><p>​ – 用户重试</p><p>​ – 代码逻辑重试</p><p>阶段三: 服务调用者不可用 -&gt;同步等待造成的资源耗尽</p><p>解决方案: </p><p>流控限流 </p><p>缓存预加载 </p><p>服务降级(保留重要的服务关闭不重要的服务；降低一致性)</p><p>服务熔断</p><p>舱壁模式 规定每个业务的最大线程数</p></blockquote><h3 id="服务熔断-断路器模式"><a href="#服务熔断-断路器模式" class="headerlink" title="服务熔断-断路器模式"></a>服务熔断-断路器模式</h3><p><img src="/img/sentinel/duanluqi-model.png"></p><blockquote><p>最开始处于closed状态，一旦检测到错误到达一定阈值，便转为open状态；</p><p>这时候会有个 reset timeout，到了这个时间了，会转移到half open状态；</p><p>尝试放行一部分请求到后端，一旦检测成功便回归到closed状态，即恢复服务；</p></blockquote><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>Sentinel 是一款开源的，且功能强大的流量控制和熔断降级框架，用于保护分布式系统的稳定性和可靠性。它主要用于应对高并发访问、突发流量和异常情况下的服务保护和流量控制。</p><p>Sentinel以流量为切入点，从流量控制熔断降级，系统负载保护等来保障服务的稳定性. </p></blockquote><h3 id="组件与功能"><a href="#组件与功能" class="headerlink" title="组件与功能"></a>组件与功能</h3><p><img src="/img/sentinel/sentinel.png"></p><blockquote><p>多种限流算法：包括令牌桶、漏桶等，可以根据业务场景选择合适的算法。</p><p>多种限流维度：包括QPS、并发线程数、异常比例等，可以根据不同的维度来进行限流。</p><p>多种应用场景：支持Dubbo、Spring Cloud、gRPC等多种RPC框架的服务发现和调用。</p><p>动态规则源：支持多种数据源，如Nacos、Zookeeper、Apollo等，可以动态推送和更新规则。</p><p>实时监控：提供实时的监控和统计功能，可以查看服务的运行状态和指标</p></blockquote><h3 id="Sentinel本地项目"><a href="#Sentinel本地项目" class="headerlink" title="Sentinel本地项目"></a>Sentinel本地项目</h3><h4 id="引入依赖-核心库"><a href="#引入依赖-核心库" class="headerlink" title="引入依赖-核心库"></a>引入依赖-核心库</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//配置流控规则</span></span><br><span class="line">       initFlowRules();</span><br><span class="line">       <span class="comment">//模拟访问</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">// 1.5.0 版本开始可以直接利用 try-with-resources 特性</span></span><br><span class="line">           <span class="keyword">try</span> (<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> SphU.entry(<span class="string">&quot;HelloWorld&quot;</span>)) &#123; <span class="comment">//HelloWorld 资源呢的名字</span></span><br><span class="line">               <span class="comment">// 被保护的逻辑</span></span><br><span class="line">               System.out.println(<span class="string">&quot;要进行的操作&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">               <span class="comment">// 处理被流控的逻辑</span></span><br><span class="line">               System.out.println(<span class="string">&quot;blocked!&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="规则配置"><a href="#规则配置" class="headerlink" title="规则配置"></a>规则配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initFlowRules</span><span class="params">()</span>&#123;</span><br><span class="line">      List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//规则列表</span></span><br><span class="line">      <span class="type">FlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">      rule.setResource(<span class="string">&quot;HelloWorld&quot;</span>);<span class="comment">//此规则对HelloWorld起作用,匹配资源名</span></span><br><span class="line">          rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<span class="comment">//将规则设置为按照每秒请求数来进行限流 QPS： query per second</span></span><br><span class="line">      <span class="comment">// Set limit QPS to 20.</span></span><br><span class="line">      rule.setCount(<span class="number">200000</span>); <span class="comment">//每秒200000个请求</span></span><br><span class="line">      rules.add(rule);</span><br><span class="line">      FlowRuleManager.loadRules(rules); <span class="comment">//添加规则到规则管理器</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/img/sentinel/%E8%A7%84%E5%88%99.png"></p><blockquote><p><code>要进行的操作</code> 表示服务正常运行</p><p><code>blocked!</code>表示每秒的请求数超过规定的20000次被拒绝</p></blockquote><h3 id="Sentinel控制台"><a href="#Sentinel控制台" class="headerlink" title="Sentinel控制台"></a>Sentinel控制台</h3><h4 id="Sentinel安装与配置"><a href="#Sentinel安装与配置" class="headerlink" title="Sentinel安装与配置"></a>Sentinel安装与配置</h4><p><em>安装<code>sentinel-dashboard-1.8.6.jar</code></em></p><p>下载地址： <a href="https://github.com/alibaba/Sentinel/releases/tag/1.8.6">https://github.com/alibaba/Sentinel/releases/tag/1.8.6</a></p><p><em>启动</em></p><blockquote><p>新建一个<code>.bat</code>后缀的批处理文件,以java命令启动 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `./` 与该文件同级下的sentinel-dashboard-1.8.6.jar文件</span></span><br><span class="line">java -jar ./sentinel-dashboard-<span class="number">1.8</span><span class="number">.6</span>.jar --server.port=<span class="number">9999</span></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p><em>访问</em>Sentinel控制台</p><blockquote><p><a href="http://localhost:9999/#/login">http://localhost:9999/#/login</a></p><p>默认用户名密码都为sentinel</p></blockquote><p><em>引入依赖</em></p><blockquote><p>客户端信息需要用HttpClient接入到Sentinel客户端</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>配置启动参数</em></p><blockquote><p>指定控制台的地址和端口</p></blockquote><p><img src="/img/sentinel/sentinel-starter-config.png"></p><p><em>服务连接sentinel控制台</em></p><blockquote><p>启动SentinelApp,在控制台查看详情（图表可视化）</p></blockquote><p><img src="/img/sentinel/sentinel-app.png"></p><h4 id="动态修改阈值"><a href="#动态修改阈值" class="headerlink" title="动态修改阈值"></a>动态修改阈值</h4><blockquote><p>Sentinel控制台动态修改阈值，通过实时监控,可以看到阈值可以通过控制台在程序运行时动态实时修改</p></blockquote><p><img src="/img/sentinel/update.png"></p><h4 id="微服务整合Sentinel客户端"><a href="#微服务整合Sentinel客户端" class="headerlink" title="微服务整合Sentinel客户端"></a>微服务整合Sentinel客户端</h4><p><strong>原理图</strong></p><p><img src="/img/sentinel/sentinel-yuanli.png"></p><p><em>1.引入依赖</em></p><blockquote><p>重要子依赖</p><p>simple-http：它是一个简版的http服务器,用于与dashboard通讯,Sentinel中的simple http是一种提供HTTP端点的通信模块，用于接收来自Dashboard的控制指令</p><p>aspectj的依赖: 用于完成对目标资源的统计(流量QPS)工作（aop）</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sentinel 客户端依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>2.yml中配置sentinel服务</em></p><blockquote><p>在nacos配置中心的resfoods的配置中修改，如果使用了负载均衡策略有该项目多个配置文件,可在不同的配置文件中配置不同的sentinel端口即可</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span>  <span class="comment">#sentinel配置</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span>                  <span class="comment">#跟控制台交流的端口,随意指定一个未使用的端口即可</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:9999</span>   <span class="comment">#dashboard地址与端口</span></span><br><span class="line">      <span class="attr">eager:</span> <span class="literal">true</span>                   <span class="comment">#表示 Sentinel 会在应用启动时立即进行初始化。这意味着 Sentinel 会立即加载规则、统计信息等相关的数据，并开始监控和限流</span></span><br></pre></td></tr></table></figure><p>3.测试</p><blockquote><p>启动项目建立与sentinel夫区埃的连接,使用Jmeter测试是否可以对客户端进行监控</p></blockquote><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="/img/sentinel/rongduan-yuanli.png"></p><h3 id="慢调用"><a href="#慢调用" class="headerlink" title="慢调用"></a><strong>慢调用</strong></h3><blockquote><p>慢调用RT(最大的响应时间)</p><p>请求的响应时间大于RT则统计为慢调用</p><p>当单位统计时长(统计窗口时长)内请求数目大于设置的最小请求数目,并且慢调用的比例要大于阈值,接下来熔断时长内的额请求会被自动熔断（同时满足两个条件）</p></blockquote><p>示例: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;payAction&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">payAction</span><span class="params">(   Integer flag    )</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">//<span class="doctag">TODO:</span> 1. 测试慢请求</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//模拟慢请求</span></span><br><span class="line">        </span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;( );</span><br><span class="line">        <span class="comment">//取出当前用户的订单金额,调用第三方接口，完成支付.</span></span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>sentinel控制台配置熔断规则</em></p><p><img src="/img/sentinel/mandiaoyong_3.png"></p><p><em>在Apache Jmeter里配置请求</em></p><blockquote><p>100个请求分5秒发送,每秒20个请求</p></blockquote><p><img src="/img/sentinel/mandiaoyong_2.png"></p><p><em>发送请求,查看控制台实时监控图</em></p><p><img src="/img/sentinel/mandiaoyong_1.png"></p><blockquote><p>如图14:49:16 - 14:49:18时刻,14:49:16时刻单位统计时长内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，发生熔断,在熔断这两秒的时长内,也就是14:49:18时刻发送了一个请求测试是否有响应,经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态)</p></blockquote><h3 id="异常比例与异常数"><a href="#异常比例与异常数" class="headerlink" title="异常比例与异常数"></a><strong>异常比例与异常数</strong></h3><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;payAction&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">payAction</span><span class="params">(   Integer flag    )</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//2.异常数 这里异常比例为40%</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> r.nextInt(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// (0,1)/(0,1,2,3,4) 40%</span></span><br><span class="line">        <span class="keyword">if</span> (a==<span class="number">0</span>||a==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;发生异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;( );</span><br><span class="line">        <span class="comment">//取出当前用户的订单金额,调用第三方接口，完成支付.</span></span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>在Apche Jmeter中查看详情</em></p><blockquote><p>通过测试可以得知当前异常比大约为40%</p></blockquote><p><img src="/img/sentinel/yichangbili.png"></p><p><em>配置熔断规则</em></p><blockquote><p>这里异常数配置为6是因为,发送的请求的异常比例为40%，又因为每秒的请求数有20,当异常数为8的时候,异常比例为40%，设置为6说明我们模拟的环境是发生熔断的条件是低于40%异常比(阈值低于0.4),而程序中的异常比规定为40%，异常的比例大于阈值发生熔断</p></blockquote><p><img src="/img/sentinel/yichangshu_1.png"></p><p><em>Apche Jmeter重新发送请求,查看控制台监控图</em></p><p><img src="/img/sentinel/yichangshu_3.png"></p><h2 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h2><blockquote><p>阈值类型:<br>QPS: 单位实践类,请求接口数限制</p><p>并发线程数： 单位时间类, 请求并发数限制</p><p>单机阈值: 每秒限制的次数</p><p>流控模式: 直接  快速  失败</p><p>流控效果: 快速失败  Warm Up  排队等待</p></blockquote><blockquote><p>快速失败： 单位时间内请求数超过阈值直接拒绝</p><p>Warm Up预热时间:  冷启动,在预热时间内请求数慢慢增多直至达到达到阈值,但不超过阈值</p><p>排队等待:  在超时时间内,所有请求根据阈值限制,均匀排成多个队列进行排队等待</p></blockquote><h3 id="关联流量控制"><a href="#关联流量控制" class="headerlink" title="关联流量控制"></a>关联流量控制</h3><blockquote><p>防止两个或多个资源之间有资源争抢而影响资源吞吐量</p><p>比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢</p></blockquote><p><img src="/img/sentinel/ganlian.png"></p><h3 id="热点限流"><a href="#热点限流" class="headerlink" title="热点限流"></a><strong>热点限流</strong></h3><blockquote><p>控制热门资源的访问流量，以避免资源过载</p><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控</p></blockquote><p>1.定义资源</p><blockquote><p>在需要限流服务的方法上加入@SentinelSource(“流控资源名”)  </p></blockquote><p>2.启动服务</p><blockquote><p>启动本地服务与sentinel控制台建立连接</p></blockquote><p>3.测试</p><blockquote><p>在Apache Jmeter上配置请求，每秒100个请求,循环一次,每个请求访问第一页数据</p></blockquote><p><img src="/img/sentinel/hot_1.png"></p><blockquote><p>在sentinel控制台编辑热点规则</p><p>这里对请求进行了限流,限定了只接受两个请求</p></blockquote><p><img src="/img/sentinel/hot_2.png"></p><blockquote><p>在实时监控图中可看到只有两个请求通过，其余的请求被拒绝</p></blockquote><p><img src="/img/sentinel/hot_3.png"></p><h3 id="链路限流"><a href="#链路限流" class="headerlink" title="链路限流"></a><strong>链路限流</strong></h3><blockquote><p>只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就可以限流）[api级别的针对来源]</p></blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>1.关闭默认整合链路功能</p><blockquote><p>sentinel底层统计链路信息的时候，将多个入口的请求做了合并</p><pre><code>              machine-root               /       \              /         \        Entrance1     Entrance2           /             \          /               \ DefaultNode(nodeA)   DefaultNode(nodeA)</code></pre><p>请求不管从哪个入口进入都会进行计数，所以需要关闭默认整合链路功能，每条链路单独计数</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span> </span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment">#关闭context整合</span></span><br></pre></td></tr></table></figure><p>2.示例</p><blockquote><p>模拟订单的两个统计功能,无论哪个统计都需要访问商品信息</p><p>​                              goodsInfo</p><p>​                             &#x2F;                 \</p><p>​                          &#x2F;                        \</p><p>​                  serviceA                    serviceB</p></blockquote><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsBiz</span> &#123;</span><br><span class="line">    <span class="meta">@SentinelResource(&quot;goodsInfo&quot;)</span> <span class="comment">//将此方法定义为sentinel管理的资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goodsInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> GoodsBiz goodsBiz;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(value = &quot;serviceA&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">serviceA</span><span class="params">()</span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       goodsBiz.goodsInfo();</span><br><span class="line">       map.put(<span class="string">&quot;code&quot;</span>,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(value = &quot;serviceB&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">serviceB</span><span class="params">()</span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       goodsBiz.goodsInfo();</span><br><span class="line">       map.put(<span class="string">&quot;code&quot;</span>,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Apche Jmeter</p><p>一个线程组添加两个Http请求 serviceA  serviceB</p><p>参数:</p><ul><li>线程数 100</li><li>Ramp-Up 1</li><li>循环次数  1</li></ul></blockquote><h4 id="流控规则配置"><a href="#流控规则配置" class="headerlink" title="流控规则配置"></a>流控规则配置</h4><blockquote><p>这段配置的意思是只要goodInfo的调用次数超过2就限制service的流量</p></blockquote><p><img src="/img/sentinel/liukong_1.png"></p><p>结果</p><p><img src="/img/sentinelliukong_2.png"></p><h2 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h2><h3 id="黑白名单控制"><a href="#黑白名单控制" class="headerlink" title="黑白名单控制"></a>黑白名单控制</h3><blockquote><p>规则配置</p><p>来源访问控制规则（<code>AuthorityRule</code>）非常简单，主要有以下配置项：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象。</li><li><code>limitApp</code>：对应的黑名单&#x2F;白名单，不同 origin 用 <code>,</code> 分隔，如 <code>appA,appB</code>。</li><li><code>strategy</code>：限制模式，<code>AUTHORITY_WHITE</code> 为白名单模式，<code>AUTHORITY_BLACK</code> 为黑名单模式，默认为白名单模式。</li></ul><p>配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p></blockquote><p>官方文档:<a href="https://github.com/alibaba/Sentinel/wiki/%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E6%8E%A7%E5%88%B6">https://github.com/alibaba/Sentinel/wiki/黑白名单控制</a></p><h2 id="系统自适应限流"><a href="#系统自适应限流" class="headerlink" title="系统自适应限流"></a>系统自适应限流</h2><h3 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h3><blockquote><p>系统规则支持以下的模式：</p><ul><li><strong>Load 自适应</strong>（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li><li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li><li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li></ul></blockquote><h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><blockquote><p>我们把系统处理请求的过程想象为一个水管，到来的请求是往这个水管灌水，当系统处理顺畅的时候，请求不需要排队，直接从水管中穿过，这个请求的RT是最短的；反之，当请求堆积的时候，那么处理请求的时间则会变为：排队时间 + 最短处理时间。</p><ul><li>推论一: 如果我们能够保证水管里的水量，能够让水顺畅的流动，则不会增加排队的请求；也就是说，这个时候的系统负载不会进一步恶化。</li></ul><p>接下来的问题是，水管的水位是可以达到了一个平衡点，但是这个平衡点只能保证水管的水位不再继续增高，但是还面临一个问题，就是在达到平衡点之前，这个水管里已经堆积了多少水。如果之前水管的水已经在一个量级了，那么这个时候系统允许通过的水量可能只能缓慢通过，RT会大，之前堆积在水管里的水会滞留；反之，如果之前的水管水位偏低，那么又会浪费了系统的处理能力。</p><ul><li>推论二:　当保持入口的流量是水管出来的流量的最大的值的时候，可以最大利用水管的处理能力。</li></ul></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.添加系统规则</p><p><img src="/img/sentinel/zhishiyin_1.png"></p><p>2.单服务流量分配</p><blockquote><p>Apche Jmeter参数:</p><ul><li>线程数 100</li><li>Ramp-Up 1</li><li>循环次数  1</li></ul></blockquote><p><img src="/img/sentinel/zhishiyin_2.png"></p><p>3.多服务流量分配</p><blockquote><p>按每秒服务请求数比例进行分配</p></blockquote><p><img src="/img/sentinel/zhishiyin_3.png"></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="流控异常处理"><a href="#流控异常处理" class="headerlink" title="流控异常处理"></a>流控异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(value = &quot;findById&quot;,blockHandler = &quot;blockHandlerForFindById&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="业务异常处理"><a href="#业务异常处理" class="headerlink" title="业务异常处理"></a>业务异常处理</h3><blockquote><p>当资源出现业务异常时,统一回调一个处理方法,重组异常信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fallback 业务异常处理,handleException: 流控回调处理的方法名</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;findById&quot;,fallback = &quot;handleException&quot;)</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">handleException</span><span class="params">(Integer fid, Throwable exception)</span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;出现异常,异常信息为:&quot;</span> + exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="异常的统一处理"><a href="#异常的统一处理" class="headerlink" title="异常的统一处理"></a>异常的统一处理</h3>]]></content>
      
      
      <categories>
          
          <category> SpringCloud与微服务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤器链设计模式</title>
      <link href="/2023/11/29/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/11/29/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置中心-nacos</title>
      <link href="/2023/11/29/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-nacos/"/>
      <url>/2023/11/29/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-nacos/</url>
      
        <content type="html"><![CDATA[<h2 id="配置中心nacos"><a href="#配置中心nacos" class="headerlink" title="配置中心nacos"></a>配置中心nacos</h2><h3 id="配置文件在项目中出现的问题"><a href="#配置文件在项目中出现的问题" class="headerlink" title="配置文件在项目中出现的问题"></a>配置文件在项目中出现的问题</h3><blockquote><p>我们一般把配置文件以yml或properties的形式放在项目中,修改了配置文件之后,只有重启服务后,配置文件才能生效</p></blockquote><h3 id="配置中心优点"><a href="#配置中心优点" class="headerlink" title="配置中心优点"></a>配置中心优点</h3><blockquote><p>1.动态更新配置文件</p><p>2.统一配置管理</p><p>配置文件分级管理</p><p>与服务器状态保持一致</p><p>文件管理</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>(配置中心&gt;命令行&gt;配置文件)</p><h3 id="发布配置文件到配置中心"><a href="#发布配置文件到配置中心" class="headerlink" title="发布配置文件到配置中心"></a>发布配置文件到配置中心</h3><h4 id="1-新建命名空间"><a href="#1-新建命名空间" class="headerlink" title="1.新建命名空间"></a>1.新建命名空间</h4><p><img src="/img/nacos_centermingmin.png"></p><h4 id="2-在配置列表中新建配置"><a href="#2-在配置列表中新建配置" class="headerlink" title="2.在配置列表中新建配置"></a>2.在配置列表中新建配置</h4><p><img src="/img/nacos_center/peizhi.png"></p><blockquote><p>DataId配置规范</p><p>${prefix}-${spring.profiles.active}.${file-extension}</p><p>${prefix}:前缀 - 服务名</p><p>${spring.profiles.active}:环境名</p><p>${file-extension}:文件后缀名</p><p>将配置格式改为yaml，然后将将本地的项目的application配置文件复制到配置中，并注释掉本地配置(避免启动项目时两者发生冲突)</p></blockquote><p><img src="/img/nacos_center/peizhi-detail.png"></p><h4 id="3-导入依赖"><a href="#3-导入依赖" class="headerlink" title="3.导入依赖"></a>3.导入依赖</h4><blockquote><p>因为要在微服务启动时就要访问到nacos配置中心,所以需要导入依赖开启nacos配置中心支持</p><p>因为本地application.yml文件放入nacos中后无法访问到配置中心的配置,先要读取到bootstrap文件中nacos的有关配置信息读取到配置中心的位置后,才能读取到nacos中的配置文件，所以bootstrap.yml(启用级配置)要优先application.yml(应用级配置)配置文件先加载,</p><p>由于bootstrap.yml权限太高现在已经被springcloud禁用，需要导入bootstrap.yml启用</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        开启对bootstrap.yml的支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        开启nacos配置中心支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-新建本地bootstrap-yml配置文件"><a href="#4-新建本地bootstrap-yml配置文件" class="headerlink" title="4.新建本地bootstrap.yml配置文件"></a>4.新建本地bootstrap.yml配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置中心的地址</span></span><br><span class="line">        <span class="comment">#namespace -&gt; group -&gt;$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">res134</span> <span class="comment">#指定命名空间</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment">#分组</span></span><br><span class="line">        <span class="comment">#nacos的用户名和密码</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span> </span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">res-foods</span> <span class="comment">#服务名</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span> <span class="comment">#后缀名</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#环境名</span></span><br></pre></td></tr></table></figure><blockquote><p>配置完成后进行测试,看看日志信息中是否读取是nacos中的配置</p></blockquote><h3 id="新增产品配置"><a href="#新增产品配置" class="headerlink" title="新增产品配置"></a>新增产品配置</h3><blockquote><p>项目上线配置</p><p>新增一个res-foods-prod.yml的产品配置,只需对原配置文件端口号和bootstrap.yml中的环境配置项进行修改即可,后续配置待定进行修改</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#res-foods-prod.yml</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bootstrap.yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><h2 id="动态刷新配置"><a href="#动态刷新配置" class="headerlink" title="动态刷新配置"></a>动态刷新配置</h2><blockquote><p>新增一个显示日期的服务,用户DI注入从属性文件读取配置的方式读取到配置文件中显示日期的格式,通过修改配置中心配置文件中日期格式来感知自动刷新配置(修改配置文件后不需要重启本地服务-动态刷新配置)</p><p>要求：</p><p>引入了<code>actuator</code>的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 端点监控  用来监控当前服务节点运行状态--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为<code>@RefreshScope</code> 底层结合了<code>actuator</code>支持,且开放了<code>refreshSocpe</code>端点</p><p><img src="/img/nacos_center/actuator.png"></p><p>在修改配置文件的同时,nacos实际上向项目中resfood服务的<code>refreshSocpe</code>端点发送了一个请求（<code>http://localhost:9200/actuator/refresh</code>在尾部衔接一个参数）来告知你的属性值进行了更改</p><p><img src="/img/nacos_center/actuator_2.png"></p></blockquote><p><em>1.在Controller类中新增一个服务用于显示系统当前的时间</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;resfood&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//动态刷新配置</span></span><br><span class="line"><span class="meta">@RefreshScope</span>  <span class="comment">//这个注解只能在类和方法上标明,并且要求actuator暴露endpoints端点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResFoodController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;res.pattern.dateFormat&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//利用di机制,从属性文件读取配置,这里是时间显示的格式</span></span><br><span class="line">    <span class="keyword">private</span> String dateFormatString; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;timeService&quot;,method=&#123;RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">timeService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(dateFormatString);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dString</span> <span class="operator">=</span> df.format(date);</span><br><span class="line">        Map&lt;String ,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;obj&quot;</span>,dString);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>2.在产品配置文件中声明时间格式</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">res:</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateFormat:</span> <span class="string">yyyy:MM:dd</span> <span class="string">hh:mm:ss</span></span><br></pre></td></tr></table></figure><p><em>3.启动项目并访问新增的这个服务</em></p><p><img src="/img/nacos_center/timeService_1.png"></p><p><em>4.修改日期格式</em></p><p><img src="/img/nacos_center/update.png"></p><p><strong>自动感知属性值的变化</strong></p><p><img src="/img/nacos_center/autofeel.png"></p><p><em>5.再次访问这个服务</em></p><p><img src="/img/nacos_center/timeService_2.png"></p><blockquote><p>通过这个过程理解动态刷新配置的作用</p></blockquote><h2 id="配置文件的版本控制"><a href="#配置文件的版本控制" class="headerlink" title="配置文件的版本控制"></a>配置文件的版本控制</h2><blockquote><p>nacos提供了历史版本功能, 可以通过界面提供的历史版本模块来查看和管理配置的历史版本</p><p>可以通过详情查看当前版本的详情</p><p>可以通过回滚来恢复历史的版本</p><p>可以通过比较两个版本对比当前版本与历史版本的不同或基于历史版本所进行修改的详细内容</p></blockquote><p><img src="/img/nacos_center/version-control.png"></p><h2 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h2><p>…</p><h2 id="更新数据源"><a href="#更新数据源" class="headerlink" title="更新数据源"></a>更新数据源</h2><p>…</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud与微服务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="builder构造器设计模式"><a href="#builder构造器设计模式" class="headerlink" title="builder构造器设计模式"></a>builder构造器设计模式</h2><p>。。。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><ol><li>Observer  Observable</li><li>reactor</li><li>webflux.</li></ol></blockquote><p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2023/11/28/SpringSecurity/"/>
      <url>/2023/11/28/SpringSecurity/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2023/11/13/SpringCloud/"/>
      <url>/2023/11/13/SpringCloud/</url>
      
        <content type="html"><![CDATA[<h2 id="单体应用与分布式应用"><a href="#单体应用与分布式应用" class="headerlink" title="单体应用与分布式应用"></a>单体应用与分布式应用</h2><h3 id="什么是单体应用"><a href="#什么是单体应用" class="headerlink" title="什么是单体应用?"></a>什么是单体应用?</h3><blockquote><p>单体应用是指将一个应用程序的所有功能模块集中在一个单一的执行单元中，通常打包为一个单独的可执行文件或软件包。这个单体可以是一个WAR包，也可以是一个JAR包、一个EXE文件、一个容器镜像等。</p></blockquote><h3 id="单体应用的优缺点"><a href="#单体应用的优缺点" class="headerlink" title="单体应用的优缺点"></a>单体应用的优缺点</h3><blockquote><p>优点: </p><p>整个项目是一个web工程,运行在一个JVM中,整合性较好,开发便捷,容易管理</p><p>缺点:</p><p>1.项目越大,代码量越大,造成编译、打包 费时,越来越影响效率</p><p>2.业务增多时会造成代码冗余重复,代码复用度不高,造成浪费</p><p>前后台两个项目 -&gt; 前端: <code>http://localhost:9999</code></p><p>​     后端: <code>http://b:9999/adminLogin.html</code></p><p>例: 两个项目实体类重复</p><p>3.可伸缩性差,单体应用中的功能模块的使用场景，并发量，消耗的资源类型各有不同，对于资源的利用又互相影响，这样使我们对各个业务模块的系统容量很难给出较准确的评估</p><p>当项目只在一个规定的时间上线一个新功能时,且对并发要求度高,只能对该项目的对应的硬件升级或流量进行扩充,无法对其进行分配,对于一个单体应用来说造成了资源空间的浪费</p><p>4.系统错误隔离性差，可用性差,任何一个模块的错误均可能造成整个系统的宕机</p><p>实际业务要求其中一个服务崩溃时,其它服务均可独立运行</p></blockquote><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><blockquote><p>面向服务的架构思想</p><p>将应用程序划分为一组自治、可独立开发和部署的服务，这些服务通过消息传递或网络调用进行通信。</p></blockquote><p><em>SOA的三种架构思想</em></p><blockquote><p>SOAP: 基于HTTP + XML; <code>webservice</code>  </p><p>缺点： xml返回的 XML 数据量较大,有大量的数据冗余 例如标签名、属性名等，这会增加数据大小)</p><p>优点: 协议严格,稳定性高,安全性高</p><p>基于SOAP的天气预报: <a href="http://www.webxml.com.cn/zh_cn/weather_icon.aspx">http://www.webxml.com.cn/zh_cn/weather_icon.aspx</a></p><p>REST: 基于HTTP + JSON; <code>springcloud</code></p><p>优点: 数据简洁</p><p>缺点：字符流数据,明码传输,安全性低</p><p>RPC: 基于SOCKET+文本的形式,二进制数据； <code>alibaba dubbo</code> 典型的RPC架构;</p><p>字节流数据,可数据加密,安全性高</p></blockquote><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务?"></a>什么是微服务?</h3><blockquote><p>微服务是SOA的一种落地方案,SOA是一种面向服务的架构思想，微服务也同样推崇这种思想.</p><p>微服务架构是将一个大型应用程序分解为多个小型、自治且可独立部署的服务，以提高系统的可维护性、灵活性和扩展性。</p><p>使用脚手架实现快速开发 <code>springboot</code></p></blockquote><p><img src="/img/SpringCloud/weifuwu_1.png"></p><h2 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h2><h3 id="什么是云服务"><a href="#什么是云服务" class="headerlink" title="什么是云服务?"></a>什么是云服务?</h3><blockquote><p>云服务是一种通过互联网提供的各种资源和服务的模式,例如计算、存储、数据库、分析、机器学习等。</p><p>云服务可以根据用户的需求动态地扩展合伙缩减，而无需管理底层的硬件或软件</p></blockquote><h3 id="云服务种类及其区别"><a href="#云服务种类及其区别" class="headerlink" title="云服务种类及其区别"></a>云服务种类及其区别</h3><p><img src="/img/SpringCloud/yun/yun-class.png"></p><h2 id="微服务与云结合"><a href="#微服务与云结合" class="headerlink" title="微服务与云结合"></a>微服务与云结合</h2><blockquote><p>微服务架构的核心概念之一就是每个服务都被打包和部署为离散的独立程序。服务实例应迅速启动，服务的每一个实例都是完全相同的。</p><p>基于云的微服务以弹性的概念为中心。在需要时，可以在云上几分钟之内快速布置启动新的虚拟机和容器，如服务需求下降，可以关闭虚拟服务器。这样可显著提高应用程序的水平可伸缩性，也使应用程序更有弹性. </p></blockquote><h2 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h2><blockquote><p>cloud是一系统框架的集合(  服务注册与发现nacos&#x2F;eureka, 服务远程调用openFeign&#x2F;Feign ,服务降级，服务熔断, 服务限流 sentinel&#x2F;hystrix ，分布式事务seata，配s置中心nacos&#x2F;spring cloud config，  总线nacos&#x2F;stream ,   网关 gateway, 链路追踪 sleuth 等等,部分  )</p><p>cloud与微服务的关系: 微服务是思想, cloud是解决方案</p></blockquote><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><blockquote><p>CAP理论指出一个分布式系统中最多满足以下三项中特性其中两项</p><p>C: 一致性(Consistency)</p><p>A: 可用性(Availability)</p><p>P: 分区容错性(Partition tolerance)  &#x3D;&gt; 一定满足</p></blockquote><p><em>给定一个业务场景</em></p><p><img src="/img/SpringCloud/cap/cap_1.png"></p><blockquote><p>1.直接返回旧数据  满足 <code>AP</code></p><p>2.等待同步后返回新数据 <code>CP</code></p></blockquote><h2 id="服务注册与发现-nacos-eureka"><a href="#服务注册与发现-nacos-eureka" class="headerlink" title="服务注册与发现(nacos&#x2F;eureka)"></a>服务注册与发现(nacos&#x2F;eureka)</h2><p><img src="/img/SpringCloud/nacos_1.png"></p><blockquote><p>1.服务注册: Nacos Client会通过发送REST请求的方式向Nacos Server注册自己的服务，提供自身的元数据，比如IP地址、端口等信息</p><p>2.服务心跳: 检测 Nacos Client定时心跳持续通知Nacos Server说明服务可用,防止被删除</p><p>3.服务同步: Nacos Server集群之间会互相同步服务实例，用来保证服务信息的一致性。</p><p>为什么要使用nacos server集群?</p><p>防止单体故障</p><p>4.服务发现: 服务消费者(Nacos Client)在调用服务提供者的服务时，会发送一个REST请求给NacosServer，获取上面注册的服务清单，并且缓存在Nacos Client本地，同时会在Nacos Client本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存I</p><p>5.服务健康检查: 15s内没接收到服务心跳&#x3D;&gt;healthy&#x3D;false,30s没接收到删除该实例</p></blockquote><p>boot与cloud版本的对应</p><blockquote><p>springboot版本: <a href="https://spring.io/projects/spring-boot#learn">https://spring.io/projects/spring-boot#learn</a></p><p>boot 2.7.0-2.7.10</p><p>cloud版本:<a href="https://spring.io/projects/spring-cloud#overview">https://spring.io/projects/spring-cloud#overview</a></p><p>cloud 2021.0.6</p><p>版本对应表:<a href="https://start.spring.io/actuator/info">https://start.spring.io/actuator/info</a></p></blockquote><h2 id="Nacos开始"><a href="#Nacos开始" class="headerlink" title="Nacos开始"></a>Nacos开始</h2><h3 id="nacos安装"><a href="#nacos安装" class="headerlink" title="nacos安装"></a>nacos安装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="注册服务到nacos"><a href="#注册服务到nacos" class="headerlink" title="注册服务到nacos"></a>注册服务到nacos</h3><h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p><img src="/img/SpringCloud/nacos_server-find.png"></p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a><strong>添加依赖</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加配置到application-yml文件"><a href="#添加配置到application-yml文件" class="headerlink" title="添加配置到application.yml文件"></a><strong>添加配置到<code>application.yml</code>文件</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment">#nacos服务器的地址</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">resfood</span> <span class="comment">#服务名</span></span><br></pre></td></tr></table></figure><h4 id="启动类添加-EnableDiscoveryClient-注解-开启服务注册发现功能"><a href="#启动类添加-EnableDiscoveryClient-注解-开启服务注册发现功能" class="headerlink" title="启动类添加 @EnableDiscoveryClient 注解 开启服务注册发现功能"></a><strong>启动类添加 <code>@EnableDiscoveryClient</code> 注解 开启服务注册发现功能</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxApplication</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行application启动类注册服务</p><p>在浏览器输入<code>localhost:8848/nacos/index.html</code> 在服务列表即可查看到注册的服务</p></blockquote><p><em>配置多个服务节点(负载均衡)</em></p><p><img src="/img/SpringCloud/resfood_2.png"></p><p><em>查看服务列表的该服务下的服务详情,即可看到服务集群中存在了两个服务节点</em></p><p><img src="/img/SpringCloud/nacos_server_detail.png"></p><h4 id="配置服务消费端"><a href="#配置服务消费端" class="headerlink" title="配置服务消费端"></a><strong>配置服务消费端</strong></h4><blockquote><p>在父项目下新建一个resorder的模块</p></blockquote><p><strong>1.<code>application.yml</code>配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务器地址</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">resorder</span> <span class="comment">#注册到nacos服务上的服务名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志文件</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="comment">#指定RestTemplate包下的信息,以便在后续运行结果中能看到详细的请求信息</span></span><br><span class="line">    <span class="attr">org.springframework.web.client:</span> <span class="string">debug</span></span><br><span class="line">    <span class="attr">org.apache:</span> <span class="string">error</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="comment">#    name: mylog.log</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">logs/</span></span><br></pre></td></tr></table></figure><p><strong>2.配置启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//需要导入依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResorderApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ResorderApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><code>@EnableDiscoveryClient</code>依赖导入</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父项目已经约定了版本,子模块不需要配置版本,直接导入即可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.新增配置类</strong></p><blockquote><p>resfood模块的config包中加入以下配置文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//负载均衡 =&gt;Because: resfood服务下有两个服务节点,请求会访问哪个节点? 默认轮询策略</span></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//IOC resTemplate 对象托管到spring中</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.<code>controller</code>的配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;resorder&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">//日志信息需要导入lombok依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResorderController</span> &#123;</span><br><span class="line"><span class="comment">//注入RestTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;addCart&quot; ,method = &#123;RequestMethod.GET,RequestMethod.POST&#125; )</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">addCart</span><span class="params">(<span class="meta">@RequestParam</span> Integer fid, <span class="meta">@RequestParam</span> Integer num, HttpSession session)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//注入的 RestTemplate 对象，通过 getForObject 方法，向地址为 “http://localhost:9000/resfood/findById?fid=” + fid 的 Restful 服务发送了请求，获取指定 ID 的商品信息，并将其封装为 Map 对象返回,如果要使用负载均衡策略localhost应该改为服务名resfood。</span></span><br><span class="line">        Map&lt;String,Object&gt; result = <span class="built_in">this</span>.restTemplate.getForObject(<span class="string">&quot;http://resfood/resfood/findById?fid=&quot;</span> + fid,Map.class);</span><br><span class="line">        <span class="comment">//日志输出返回的结果</span></span><br><span class="line">        log.info(<span class="string">&quot;发送请求后返回的商品信息:&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>启动resorderApp把服务注册到nacos服务器上,在nacos服务列表检查服务是否注册成功</p></blockquote><p><strong>5.在postman中检测该服务是否可用</strong></p><p><img src="/img/SpringCloud/addCart-log-result.png"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p>a.将请求的地址由固定的 ip:端口 的方式改为 通过服务名访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//负载均衡需要用服务名resfood访问才能起作用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(resfood)          服务名   请求前缀@RequestMapping</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://resfood/resfood/findById?fid=&quot;</span>+fid;</span><br><span class="line">Map&lt;String,Object&gt; result = <span class="built_in">this</span>.restTemplate.getForObject(url,Map.class);</span><br></pre></td></tr></table></figure><p>b.映入loadbalancer依赖</p><blockquote><p>在resorder模块 客户端(消费端)加入此依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入riboon,客户端保存服务列表信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c.在客户端组件RestTemplate上加入@LoadBalanced</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//负载均衡 =&gt; resfood服务下有两个服务节点 一个请求会访问哪个节点?</span></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//IOC restemplate 对象托管spring</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置不同的负载均衡策略"><a href="#配置不同的负载均衡策略" class="headerlink" title="配置不同的负载均衡策略"></a>配置不同的负载均衡策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案一: 全局配置负载均衡策略</span></span><br><span class="line">            <span class="comment">//@LoadBalancerClient(name = &quot;resfood&quot;,configuration=&#123;  MyBalancerConfinguration.class &#125;)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//方案二：　对每个服务分别指定负载均衡策略</span></span><br><span class="line">        <span class="meta">@LoadBalancerClients(</span></span><br><span class="line"><span class="meta">                    value = &#123;</span></span><br><span class="line"><span class="meta">        @LoadBalancerClient(value = &quot;resfood&quot;, </span></span><br><span class="line"><span class="meta">                            configuration =MyBalancerConfinguration.class)&#125;,</span></span><br><span class="line"><span class="meta">                defaultConfiguration = LoadBalancerClientConfiguration.class)</span></span><br></pre></td></tr></table></figure><h3 id="自定义负载均衡器"><a href="#自定义负载均衡器" class="headerlink" title="自定义负载均衡器"></a>自定义负载均衡器</h3><h4 id="通过spring-cloud-starter-loadbalancer启动配置的源码剖析"><a href="#通过spring-cloud-starter-loadbalancer启动配置的源码剖析" class="headerlink" title="通过spring-cloud-starter-loadbalancer启动配置的源码剖析"></a><strong>通过<code>spring-cloud-starter-loadbalancer</code>启动配置的源码剖析</strong></h4><p><em>1.在外部库中找到此jar包</em></p><blockquote><p>发现starter类中导入了loadbalancer负载均衡的依赖</p></blockquote><p><img src="/img/SpringCloud/loadbalancer-starter/1.png"></p><p><em>2.跟踪<code>spring-cloud-loadbalancer</code>在外部库的jar包</em></p><blockquote><p>在此jar包中发现其中的spring工厂中启用了负载均衡的配置类</p></blockquote><p><img src="/img/SpringCloud/loadbalancer-starter/2.png"></p><p><em>3.继续跟踪该自动配置类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是一个Spring配置类，不是代理对象生成,关闭代理模式</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//负载均衡客户端可以配置多个,这里是所有的客户端都遵循此配置类</span></span><br><span class="line"><span class="meta">@LoadBalancerClients</span></span><br><span class="line"><span class="comment">//将 LoadBalancerClientsProperties.class 类型的配置属性绑定到 Spring 环境中,并启用</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;LoadBalancerClientsProperties.class&#125;)</span></span><br><span class="line"><span class="comment">//优于ReactorLoadBalancerClientAutoConfiguration和 LoadBalancerBeanPostProcessorAutoConfiguration进行自动配置。</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(&#123;ReactorLoadBalancerClientAutoConfiguration.class, LoadBalancerBeanPostProcessorAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;spring.cloud.loadbalancer.enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    havingValue = &quot;true&quot;, </span></span><br><span class="line"><span class="meta">    matchIfMissing = true //没有配置默认为true值</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里LoadBalancerClientFactory产生LoadBalancer客户端,是我们需要的</span></span><br><span class="line"><span class="comment">//声明一个 Bean，用于提供负载均衡器的工厂实例</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span> <span class="comment">//没有其他同类型的 Bean 定义的情况下，才创建该Bean。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalancerClientFactory <span class="title function_">loadBalancerClientFactory</span><span class="params">(LoadBalancerClientsProperties properties)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/img/SpringCloud/loadbalancer-starter/3.png"></p><p><em>4.追踪<code>LoadBalancerClientFactory</code></em></p><blockquote><p>找到该bean工厂中的getInstance方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReactiveLoadBalancer&lt;ServiceInstance&gt; <span class="title function_">getInstance</span><span class="params">(String serviceId)</span></span><br></pre></td></tr></table></figure><blockquote><p>该方法的作用是获取指定服务的负载均衡实例，返回一个<code>ReactiveLoadBalancer</code>类型的对象。其中，<code>serviceId</code>参数表示服务的标识符，根据<code>serviceId</code>获取相关的负载均衡客户端，并返回一个负载均衡实例；</p></blockquote><p><img src="/img/SpringCloud/loadbalancer-starter/4.png"></p><p><em>5.继续追踪<code>ReactorServiceInstanceLoadBalancer</code></em></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;ReactorLoadBalancer的标识接口,允许选择服务实例对象</span><br><span class="line">&gt;在服务接口中选取一种进行查看,这里选的是轮询负载均衡</span><br></pre></td></tr></table></figure></blockquote><p><img src="/img/SpringCloud/loadbalancer-starter/5.png"></p><p><em>6.查看RoundRobinLoadBalancer源码</em></p><blockquote><p>轮询算法：</p><p>原子整型 默认为0</p><ol><li><p>初始时 <code>this.position</code> 的值为 0。</p></li><li><p><code>this.position.incrementAndGet()</code> 将 <code>this.position</code> 的值加 1，变为 1。</p></li><li><pre><code> &amp; 2147483647  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  进行位与运算：</span><br><span class="line"></span><br><span class="line">  - 1 的二进制表示为：`00000000000000000000000000000001`</span><br><span class="line">  - 2147483647 的二进制表示为：`01111111111111111111111111111111`</span><br><span class="line">  - 进行按位与运算：`00000000000000000000000000000001`</span><br><span class="line">  - 得到的结果是 1。</span><br><span class="line"></span><br><span class="line">&gt;4. `(pos % instances.size())` 计算 1 除以 3 的余数，结果为 1。</span><br><span class="line"></span><br><span class="line">&gt;5. 通过 `instances.get(1)` 获取 `instances` 列表中索引为 1 的元素。</span><br><span class="line"></span><br><span class="line">&gt;接下来继续执行相同的运算步骤即可</span><br><span class="line"></span><br><span class="line">&gt;`(pos % instances.size())`=0时,算法完成一个循环,归0</span><br><span class="line"></span><br><span class="line">![](/img/SpringCloud/loadbalancer-starter/6.png)</span><br><span class="line"></span><br><span class="line">#### 自定义一个负载均衡器</span><br><span class="line"></span><br><span class="line">&gt;只访问一个服务 `OnlyOneLoadBalancer` 负载均衡器</span><br><span class="line"></span><br><span class="line">*1.写一个`LoadBalancer`类实现`ReactorServiceInstanceLoadBalancer` 接口*</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Slf4j</span><br><span class="line">public class OnlyOneLoadBalancer implements ReactorServiceInstanceLoadBalancer &#123;</span><br><span class="line">   private ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider;</span><br><span class="line"></span><br><span class="line">   public OnlyOneLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider) &#123;</span><br><span class="line">       this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123;</span><br><span class="line">       ServiceInstanceListSupplier supplier = serviceInstanceListSupplierProvider.getIfAvailable(NoopServiceInstanceListSupplier::new);</span><br><span class="line">       return supplier.get(request).next().map((serviceInstances) -&gt; &#123;</span><br><span class="line">           return processInstanceResponse(supplier, serviceInstances);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private Response&lt;ServiceInstance&gt; processInstanceResponse(ServiceInstanceListSupplier supplier,</span><br><span class="line">                                                             List&lt;ServiceInstance&gt; serviceInstances) &#123;</span><br><span class="line">       Response&lt;ServiceInstance&gt; serviceInstanceResponse = getInstanceResponse(serviceInstances);</span><br><span class="line">       if (supplier instanceof SelectedInstanceCallback &amp;&amp; serviceInstanceResponse.hasServer()) &#123;</span><br><span class="line">           ((SelectedInstanceCallback) supplier).selectedServiceInstance(serviceInstanceResponse.getServer());</span><br><span class="line">       &#125;</span><br><span class="line">       return serviceInstanceResponse;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private Response&lt;ServiceInstance&gt; getInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123;</span><br><span class="line">       log.info(&quot;自定义负载&quot;);</span><br><span class="line">       if (instances.isEmpty()) &#123;</span><br><span class="line">           return new EmptyResponse();</span><br><span class="line">       &#125;</span><br><span class="line">       //固定访问第1个服务</span><br><span class="line">       ServiceInstance instance = instances.get(0);</span><br><span class="line"></span><br><span class="line">       return new DefaultResponse(instance);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></blockquote><p><em>2.用于自定义负载均衡器的配置类</em></p><blockquote><p>定义了一个名为OnlyOneLoadBalancerConfiguration的@Configuration注解类，使用@Bean注解托管,声明了一个名为OnlyOneReactorServiceInstanceLoadBalancer的方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnlyOneLoadBalancerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置自定义策略</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> ReactorServiceInstanceLoadBalancer <span class="title function_">OnlyOneReactorServiceInstanceLoadBalancer</span><span class="params">(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;</span><br><span class="line">            <span class="comment">//使用getProperty方法从Environment对象中获取负载均衡器的名称属性值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);</span><br><span class="line">            <span class="comment">//随机RandomLoadBalancer；轮询RoundRobinLoadBalancer</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OnlyOneLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>3.在客户端组件RestTemplate上加入@LoadBalanced</em></p><blockquote><p>这段代码配置了使用自定义的负载均衡器去负载均衡访问名为”resfood”和”resorder”的服务，并且通过@LoadBalanced注解将RestTemplate设置为负载均衡的实例。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//服务名绑定负载均衡策略</span></span><br><span class="line"><span class="meta">@LoadBalancerClients(</span></span><br><span class="line"><span class="meta">    //resfood和resorder服务使用自定义的负载均衡策略,其它的服务使用默认的轮询负载均衡策略</span></span><br><span class="line"><span class="meta">        value = &#123; </span></span><br><span class="line"><span class="meta">  @LoadBalancerClient(value = &quot;resfood&quot;,configuration = OnlyOneLoadBalancerConfiguration.class),</span></span><br><span class="line"><span class="meta">            @LoadBalancerClient(value = &quot;resorder&quot;,configuration = OnlyOneLoadBalancerConfiguration.class),</span></span><br><span class="line"><span class="meta">        &#125;,defaultConfiguration = LoadBalancerClientConfiguration.class</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//负载均衡 =&gt; resfood服务下有两个服务节点 一个请求会访问哪个节点?</span></span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//IOC restemplate 对象托管spring</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><h3 id="OpenFeign-1"><a href="#OpenFeign-1" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><blockquote><p>SpringCloud OpenFeign是一种声明式的REST客户端</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>开发者只需要定义服务接口并用注解描述服务即可,其余都交给<code>OpenFeign</code> 处理</p><p>OpenFeign在项目启动时生成动态代理类,代理类集成了负载均衡器，可以自动选择服务实例并发送请求</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote><p>自动集成Ribbon，实现客户端负载均衡。</p><p>自动集成Hystrix，实现服务降级和熔断。</p><p>自动集成Eureka或Consul，从服务注册中心获取服务列表。</p><p>可以自定义Feign的组件，如编码器，解码器，拦截器等</p></blockquote><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><blockquote><p>HTTP请求调用的轻量级框架(底层jdk面向接口的动态代理)</p><p>封装了HTTP 调用了流程,面向接口编程 &#x3D;&gt;java注解方式调用Http请求</p><p>请求模板化,要进行适配,根据传入的参数应用在对应的请求上,进而转化为真正的请求</p></blockquote><h3 id="为什么使用Feign和OpenFeign"><a href="#为什么使用Feign和OpenFeign" class="headerlink" title="为什么使用Feign和OpenFeign"></a>为什么使用Feign和OpenFeign</h3><blockquote><p>Feign和OpenFeign的作用是简化和优化微服务架构中服务之间的HTTP调用。</p><p>传统的HTTP调用需要手动编写大量的代码来处理请求的创建、发送、接收和解析等过程，而且还需要处理负载均衡、熔断等场景。这使得开发者要花费大量的精力来处理这些细节，增加了开发的复杂度和工作量。</p></blockquote><h3 id="Feign开始"><a href="#Feign开始" class="headerlink" title="Feign开始"></a>Feign开始</h3><blockquote><p>实现Feign 客户端发送 HTTP 请求到指定的 GitHub 仓库地址，并获取该仓库的贡献者列表，并将结果打印输出的功能。</p></blockquote><p><em>1.引入依赖</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>10.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>10.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>2.实体类</em></p><blockquote><p>OpenFeign代码贡献者的数据实体类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Contributor</span> &#123;</span><br><span class="line">    String login;</span><br><span class="line">    <span class="type">int</span> contributions;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String node_id;</span><br><span class="line">    String avatar_url;</span><br><span class="line">    String gravatar_id;</span><br><span class="line">    String url;</span><br><span class="line">    String html_url;</span><br><span class="line">    String followers_url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Contributor&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;login=&#x27;&quot;</span> + login + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, contributions=&quot;</span> + contributions +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, node_id=&#x27;&quot;</span> + node_id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, avatar_url=&#x27;&quot;</span> + avatar_url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gravatar_id=&#x27;&quot;</span> + gravatar_id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, url=&#x27;&quot;</span> + url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, html_url=&#x27;&quot;</span> + html_url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, followers_url=&#x27;&quot;</span> + followers_url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>3.Feign 的接口定义</em></p><blockquote><p>该接口使用 Feign 提供的注解和方法规范，声明了一个获取 GitHub 贡献者列表的方法（contributors）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GitHub</span> &#123;</span><br><span class="line">    <span class="comment">// 传入的参数后可以拼接成url: https://api.github.com/repos/OpenFeign/feign/contributors</span></span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span> <span class="comment">//feign 提供的规范</span></span><br><span class="line"><span class="comment">// SpringMVC的注解形式   @RequestMapping(&#123;value=&quot;/repos/&#123;owner/&#123;repo&#125;/contributor,method=&#123;GET&#125;)&quot;&#125;</span></span><br><span class="line"><span class="comment">//    List&lt;Contributor&gt; contributors(@PathVariable(&quot;owner&quot;) String owner, @PathVariable(&quot;repo&quot;) String repo);</span></span><br><span class="line">    List&lt;Contributor&gt; <span class="title function_">contributors</span><span class="params">(<span class="meta">@Param(&quot;owner&quot;)</span> String owner, <span class="meta">@Param(&quot;repo&quot;)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.测试</p><blockquote><p>调用 GitHub 接口中的 contributors() 方法，传入 “OpenFeign” 和 “feign” 作为 owner 和 repo 的值，以获取贡献者列表。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        生成的代理类文件的保存路径</span></span><br><span class="line">        System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">GitHub</span> <span class="variable">github</span> <span class="operator">=</span> Feign.builder() <span class="comment">//Feign客户端的构造器</span></span><br><span class="line">                .decoder(<span class="keyword">new</span> <span class="title class_">GsonDecoder</span>()) <span class="comment">//gson解码器将json数据转为java对象</span></span><br><span class="line">            </span><br><span class="line">  <span class="comment">// target() 方法指定我们要请求的 GitHub 接口访问地址的前缀为2 “https://api.github.com”</span></span><br><span class="line">                .target(GitHub.class, <span class="string">&quot;https://api.github.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印输出者信息</span></span><br><span class="line">        List&lt;Contributor&gt; contributors = github.contributors(<span class="string">&quot;OpenFeign&quot;</span>, <span class="string">&quot;feign&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">            System.out.println(contributor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OpenFeign-Api暴露"><a href="#OpenFeign-Api暴露" class="headerlink" title="OpenFeign-Api暴露"></a>OpenFeign-Api暴露</h3><blockquote><p>OpenFeign API暴露是指将一个Feign客户端声明为一个Spring Bean并对外暴露，使其它组件可以注入和使用，这样可以方便地在其它组件中使用Feign客户端来进行微服务之间的HTTP调用。</p></blockquote><p><em>1.导入OpenFeign的依赖</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>2.导入项目的bean(实体类)</em></p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>res-bean<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p><em>3.创建api服务，在此服务中加入要公开 API接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;resfood&quot;)</span><span class="comment">//指定服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResfoodApi</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;resfood/detailCountAdd&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">detailCountAdd</span><span class="params">(<span class="meta">@RequestParam</span> Integer fid)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping( &quot;resfood/findById/&#123;fid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> Integer fid)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;resfood/findAll&quot;)</span></span><br><span class="line"><span class="comment">//    @ApiOperation(value = &quot;查询所有菜品&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;resfood/findByPage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">findByPage</span><span class="params">(<span class="meta">@RequestParam</span> <span class="type">int</span> pageno,<span class="meta">@RequestParam</span> <span class="type">int</span> pagesize,<span class="meta">@RequestParam(required = false)</span>  String sortby,<span class="meta">@RequestParam</span> (required = <span class="literal">false</span>)</span> String sort) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>4.在调用端引入依赖和api服务端</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>res-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>5.注入api接口到controller或业务层</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;resorder&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResorderController</span> &#123;</span><br><span class="line"><span class="comment">//注入api接口</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResfoodApi resfoodApi;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;addCart&quot; ,method = &#123;RequestMethod.GET,RequestMethod.POST&#125; )</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">addCart</span><span class="params">(<span class="meta">@RequestParam</span> Integer fid, <span class="meta">@RequestParam</span> Integer num, HttpSession session)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//利用Openfeign中暴露的api接口直接调用</span></span><br><span class="line">        Map&lt;String,Object&gt; result = resfoodApi.findById(fid);</span><br><span class="line">        log.info(<span class="string">&quot;发送请求后返回的商品信息:&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>6.在主启动类上添加<code>@EnableFeignClients</code></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//指定api的包路径</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &#123;&quot;com.yc.api&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResorderApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ResorderApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送请求,控制台查看结果</p></blockquote><p><img src="/img/SpringCloud/openfeign_result.png"></p><blockquote><p>一般使用步骤:  1.创建api服务. 在此服务中加入要公开  API接口               <dependency>                  <groupId>org.springframework.cloud</groupId>                  <artifactId>spring-cloud-starter-openfeign</artifactId>              </dependency>  2. 在这个api服务中开发  接口:        @FeignClient(“resfood”)       public interface ResfoodApi {           @RequestMapping( value&#x3D;”resfood&#x2F;detailCountAdd” , method&#x3D;RequestMethod.GET)           public Map&lt;String, Object&gt; detailCountAdd(Integer fid);                   }  3. 调用端开发:          <dependency>                  <artifactId>res-api</artifactId>                  <groupId>org.example</groupId>                  <version>1.0-SNAPSHOT</version>              </dependency>                    <dependency>                  <groupId>org.springframework.cloud</groupId>                  <artifactId>spring-cloud-starter-openfeign</artifactId>              </dependency>                b)开启openfeign的客户端            @EnableFeignClients(basePackages&#x3D; {“com.yc.api”})       c)注入api接口到controller或业务层.               @Autowired              private ResfoodApi resfoodApi;</p></blockquote><h3 id="Feign中的组件"><a href="#Feign中的组件" class="headerlink" title="Feign中的组件"></a>Feign中的组件</h3><p>。。。</p><h3 id="OpenFeign日志配置"><a href="#OpenFeign日志配置" class="headerlink" title="OpenFeign日志配置"></a>OpenFeign日志配置</h3><p>官方文档地址:<a href="https://docs.spring.io/spring-cloud-openfeign/docs/3.1.8/reference/html/#feign-logging">https://docs.spring.io/spring-cloud-openfeign/docs/3.1.8/reference/html/#feign-logging</a></p><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><blockquote><p>在客户端(调用api)的yml配置文件添加以下代码</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.yc.api:</span> <span class="string">DEBUG</span> <span class="comment">#被调用api的包路径，官方文档要求DEBUG日志级别才能输出</span></span><br></pre></td></tr></table></figure><h4 id="客户端单独配置"><a href="#客户端单独配置" class="headerlink" title="客户端单独配置"></a>客户端单独配置</h4><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Logger.Level</span><br></pre></td></tr></table></figure><ul><li><code>NONE</code>，无日志记录（<strong>默认</strong>）。</li><li><code>BASIC</code>，仅记录请求方法和 URL 以及响应状态码和执行时间。</li><li><code>HEADERS</code>，记录基本信息以及请求和响应标头。</li><li><code>FULL</code>，记录请求和响应的标头、正文和元数据。</li></ul></blockquote><p><em>openfeign客户端单独配置</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenFeignLogConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLever</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//FULL输出所有的日志</span></span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送请求查看日志"><a href="#发送请求查看日志" class="headerlink" title="发送请求查看日志"></a>发送请求查看日志</h4><p><img src="/img/SpringCloud/logging_print.png"></p><h3 id="网络压缩"><a href="#网络压缩" class="headerlink" title="网络压缩"></a>网络压缩</h3><h4 id="为什么要使用网络压缩"><a href="#为什么要使用网络压缩" class="headerlink" title="为什么要使用网络压缩?"></a>为什么要使用网络压缩?</h4><blockquote><p>在网络传输中数据存在一些冗余的字符,像json数据中的换行符、空格,都会带来大量的流量损耗,而OpenFeign 提供了对 Gzip 压缩的支持，在网络传输中，通过对 HTTP 请求和响应进行 Gzip 压缩，可以减少传输数据的大小，缩短传输时间，降低网络带宽的消耗和服务器压力，从而提高系统的性能和稳定性。</p></blockquote><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><em>1.yml配置</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="comment">#可以被压缩的类型</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">text/xml</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">application/xml</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">application/json</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">2048</span> <span class="comment">#超过2048字节进行压缩</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><em>2.源码剖析</em></p><blockquote><p>理解配置项为什么要这样配置</p></blockquote><p>请参考:<a href="https://forestcat.blog.csdn.net/article/details/109077317">https://forestcat.blog.csdn.net/article/details/109077317</a></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="原子整型"><a href="#原子整型" class="headerlink" title="原子整型"></a>原子整型</h3><p>AtomicInteger.incrementAndGet();</p><p>i++ ;</p><p>底层</p><blockquote><p>i&#x3D;0;</p><p>i&#x3D;i+1;</p><p>多线程编程无法保证执行顺序</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringCloud与微服务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/11/04/Redis/"/>
      <url>/2023/11/04/Redis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2023/11/04/Docker/"/>
      <url>/2023/11/04/Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是docker？"><a href="#什么是docker？" class="headerlink" title="什么是docker？"></a>什么是docker？</h2><blockquote><p>Docker是一种<strong>轻量级的虚拟化技术</strong>，同时是一个开源的应用容器运行环境搭建平台，可以让开发者以便捷方式打包应用到一个可移植的容器中，然后安装至任何运行Linux或Windows等系统的服务器上。 相较于传统虚拟机，Docker容器提供轻量化的虚拟化方式、安装便捷、启停速度快。</p></blockquote><h2 id="docker的安装"><a href="#docker的安装" class="headerlink" title="docker的安装"></a>docker的安装</h2><h3 id="下载DockerDeskTop"><a href="#下载DockerDeskTop" class="headerlink" title="下载DockerDeskTop"></a>下载DockerDeskTop</h3><p>DockerDeskTop下载地址: <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a></p><h3 id="配置Docker环境"><a href="#配置Docker环境" class="headerlink" title="配置Docker环境"></a><strong>配置Docker环境</strong></h3><p><strong>1.启动Hyper服务</strong></p><p><img src="/img/docker/hyper.png"></p><p><strong>如果计算机windows功能中没有Hyper服务</strong></p><p><strong>新建一个文本文件,将下列命令加入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line">for /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line">del hyper-v.txt</span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure><p><strong>修改文件名为Hyper.cmd</strong></p><p><strong>以管理员身份运行该程序,运行完毕后，在windows服务中启动该服务即可</strong></p><p><strong>2.检查是否配置成功</strong></p><p><img src="/img/docker/xunihua.png"></p><p><strong>3.配置一些国内镜像站点加速</strong></p><p>在这个配置中，列出了一些常用的国内镜像站点，比如阿里云、网易云、七牛云、中科大和Docker中国官方镜像。这些镜像站点的作用是提供一个与Docker官方镜像仓库相连的代理服务，可以加速Docker镜像的下载和上传过程。</p><p><strong>在docker设置选项的Docker Engine栏的配置项中修改成下列json格式的配置项</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;builder&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;gc&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;defaultKeepStorage&quot;</span>: <span class="string">&quot;20GB&quot;</span>,</span><br><span class="line">      <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;experimental&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://bytkgxyr.mirror.aliyuncs.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://reg-mirror.qiniu.com/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.验证docker环境及其桌面版是否能使用</strong></p><p><strong>powershell 管理员  输入docker version检查版本</strong></p><p><img src="/img/docker/version.png"></p><p><strong>cmd命令窗口输入docker run hello-world验证Docker桌面版</strong> </p><p><img src="/img/docker/hello-world.png"></p><p><strong>至此docker环境搭建完毕</strong></p><h2 id="docker基本命令的使用"><a href="#docker基本命令的使用" class="headerlink" title="docker基本命令的使用"></a>docker基本命令的使用</h2><table><thead><tr><th align="center"><span style="display:inline-block;width:40px">命令</span></th><th align="center"><span style="display:inline-block;width:80px">作用</span></th></tr></thead><tbody><tr><td align="center">docker search <code>...</code></td><td align="center">在 Docker registry 中搜索镜像</td></tr><tr><td align="center">docker pull <code>image</code></td><td align="center">从 Docker registry 下载指定镜像</td></tr><tr><td align="center">docker push <code>image</code></td><td align="center">将本地的镜像推送到 Docker registry</td></tr><tr><td align="center">docker <code>images</code></td><td align="center">查看当前拥有的所有镜像</td></tr><tr><td align="center">docker rmi <code>image</code></td><td align="center">删除指定的镜像</td></tr><tr><td align="center">docker run <code>image</code></td><td align="center">根据当前镜像创建并启动一个容器</td></tr><tr><td align="center">docker ps</td><td align="center">列出当前正在运行的容器</td></tr><tr><td align="center">docker stop <code>container</code></td><td align="center">停止当前指定的容器运行</td></tr><tr><td align="center">docker rm <code>container</code></td><td align="center">删除指定的容器名</td></tr><tr><td align="center">docker inspect <code>coontainer</code></td><td align="center">获取一个或多个容器的底层信息</td></tr><tr><td align="center">docker exec <code>container</code> <code>command</code></td><td align="center">在指定的容器内部执行指定命令</td></tr><tr><td align="center">docker logs <code>container</code></td><td align="center">获取指定容器的日志</td></tr></tbody></table><p>更多命令请参考docker官方API文档:   <a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><h2 id="MySql容器的部署"><a href="#MySql容器的部署" class="headerlink" title="MySql容器的部署"></a>MySql容器的部署</h2><p>搜索MySql镜像:</p><blockquote><p>docker search mysql</p></blockquote><p>拉取MySql的镜像:</p><blockquote><p>docker pull mysql</p></blockquote><p>利用镜像创建容器:  </p><blockquote><p>docker run  -p 3308:3306 –name mysql_1 -e MYSQL_ROOT_PASSWORD&#x3D;a -d  mysql –character-set-server&#x3D;utf8mb4 –collation-server&#x3D;utf8mb4_unicode_ci</p></blockquote><blockquote><ul><li><code>docker run</code>: Docker命令，用于创建和运行容器。</li><li><code>-p 3308:3306</code>: 指定容器的端口映射，将容器的端口3306映射到主机的端口3308。格式为<code>主机端口:容器端口</code>。</li><li><code>--name mysql_1</code>: 为容器指定名称为mysql_1，方便后续管理。</li><li><code>-e MYSQL_ROOT_PASSWORD=a</code>: 设置MySQL容器的root用户的密码为a。</li><li><code>-d</code>: 让容器在后台运行。</li><li><code>mysql</code>: 指定要使用的Docker镜像，这里使用的是MySQL镜像。</li><li><code>--character-set-server=utf8mb4</code>: 设置MySQL服务器的字符集为utf8mb4。</li><li><code>--collation-server=utf8mb4_unicode_ci</code>: 设置MySQL服务器的字符排序规则为utf8mb4_unicode_ci。</li><li><code>-e MYSQL_ROOT_PASSWORD=a</code>： 连接到该数据库需要密码认证</li></ul></blockquote><p>进入到容器的bash命令行环境: </p><blockquote><p>docker exec -it msql_1 &#x2F;bin&#x2F;bash</p></blockquote><p>登录mysql</p><blockquote><p>mysql -uroot -pa</p></blockquote><p>创建数据库</p><blockquote><p>create database data_1 default character set&#x3D;’utf8’</p></blockquote><h2 id="docker容器间的相互访问"><a href="#docker容器间的相互访问" class="headerlink" title="docker容器间的相互访问"></a>docker容器间的相互访问</h2><h3 id="docker的网络桥接模式"><a href="#docker的网络桥接模式" class="headerlink" title="docker的网络桥接模式"></a>docker的网络桥接模式</h3><blockquote><p>Docker 的网络桥接模式是一种允许容器通过一个网桥与宿主机或其他容器进行通信的网络模式。在桥接模式下，Docker 会为每个容器创建一个虚拟网络接口，并为其分配一个 IP 地址。这样，每个容器都可以通过桥连接与同一主机上的其他容器或宿主机进行通信。</p></blockquote><p><strong>优点</strong></p><blockquote><p>桥接模式的优点之一是容器间的通信非常简单。容器可以使用它们的 IP 地址直接相互通信，就像它们在同一物理网络中一样。此外，桥接模式还允许容器与宿主机进行通信，以及容器与外部网络进行通信</p></blockquote><p><strong>原理图</strong></p><p><img src="/img/docker/dockerBridge-yuanli.png"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th align="center"><span style="display:inline-block;width:40px">命令</span></th><th align="center"><span style="display:inline-block;width:80px">作用</span></th></tr></thead><tbody><tr><td align="center">docker network create -d <code>bridge</code></td><td align="center">创建bridge网络</td></tr><tr><td align="center">docker network ls</td><td align="center">查看所有网络</td></tr><tr><td align="center">docker network inspect <code>bridge</code></td><td align="center">查看某个网络详情</td></tr><tr><td align="center">docker network remove <code>bridge</code></td><td align="center">删除某个网络</td></tr><tr><td align="center">docker network connect <code>bridge</code> <code>container</code></td><td align="center">将一个容器连接到网桥</td></tr><tr><td align="center">docker network disconnect <code>bridge</code> <code>container</code></td><td align="center">将容器从网桥中移除</td></tr></tbody></table><h3 id="实例-两个容器通过-Bridge网络-实现互联"><a href="#实例-两个容器通过-Bridge网络-实现互联" class="headerlink" title="实例:  两个容器通过 Bridge网络  实现互联"></a>实例:  两个容器通过 <code>Bridge网络</code>  实现互联</h3><p><strong>1.建立两个MySql容器并启动</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run  -p 3309:3306 --name mysql_1 -e MYSQL_ROOT_PASSWORD=a -d  mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">    </span><br><span class="line">docker run  -p 3310:3306 --name mysql_2 -e MYSQL_ROOT_PASSWORD=a -d  mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci    </span><br></pre></td></tr></table></figure><p><strong>2.用 <code>docker ps -a</code> 命令查看两个容器是否启动</strong></p><p><img src="/img/docker/dockerBridge-shili_1.png"></p><p><strong>3.创建一个bridge, 将两个容器都连接上它,查看网络详情是否两个容器连接上了了同一个bridge网络</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新建一个名为bridge_1的bridge网络</span><br><span class="line">docker network create -d bridge bridge_1</span><br><span class="line"></span><br><span class="line">将mysql_1容器加入bridge_1网络</span><br><span class="line">docker network connect bridge_1 mysql_1</span><br><span class="line"></span><br><span class="line">将mysql_1容器加入bridge_1网络</span><br><span class="line">docker network connect bridge_1 mysql_2</span><br></pre></td></tr></table></figure><p><strong>查看网络详情</strong></p><p><img src="/img/docker/shili_1_p1.png"></p><p><strong>4.实现两个容器相互访问</strong></p><p><span style="color:red">为了可以更加直观看到两台容器互联的效果,我们在mysql_1容器中创建一个名为data_1的数据库(建立数据库代码可以参考 <code>MySql容器的部署</code> ),然后登录mysql_2容器通过远程连接mysql_1容器</span></p><p><strong>1.以-it交互式终端进入其中一台容器mysql_2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql_2 /bin/bash</span><br></pre></td></tr></table></figure><p><strong>2.用mysql_2容器连接到数据库mysql_1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//172.19.0.2为mysql_1所分配的地址</span></span><br><span class="line">myql -h <span class="number">172.19</span><span class="number">.0</span><span class="number">.2</span> -uroot -pa</span><br></pre></td></tr></table></figure><p><strong>3.用 <code>show databases; </code>命令查看详情</strong></p><p><img src="/img/docker/shili_1_p2.png"></p><p>如图上图mysql_2容器通过bridge网络完成了对mysql_1连接,并且成功访问到 mysql_1中含有<code>data_1</code>数据库,说明两个容器实现了相互访问</p><h2 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h2><h3 id="FastDFS是什么"><a href="#FastDFS是什么" class="headerlink" title="FastDFS是什么?"></a>FastDFS是什么?</h3><blockquote><p>FastDFS是一个开源的分布式文件系统，用于实现大规模文件存储和访问。它由两部分组成：Tracker Server 和 Storage Server。</p><p>Tracker Server 跟踪和管理 Storage Server 的状态，负责客户端请求的负载均衡和文件定位。</p><p>Storage Server 负责实际的文件存储和访问，它们之间可以水平扩展，可以根据需要添加更多的 Storage Server 实例来增加存储容量和吞吐量。</p><p>FastDFS 提供了高可靠性、高扩展性和高性能的文件存储解决方案。它适用于需要存储大量文件的应用场景，如图片上传、视频处理等。同时，FastDFS 还提供了灵活的接口和工具，使开发者能够方便地集成和使用。</p></blockquote><h3 id="FastDFS的安装与部署"><a href="#FastDFS的安装与部署" class="headerlink" title="FastDFS的安装与部署"></a>FastDFS的安装与部署</h3><p><strong>fastDFS镜像</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找FastDFS镜像</span></span><br><span class="line"></span><br><span class="line">docker search tracker</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉取镜像</span></span><br><span class="line"></span><br><span class="line">docker pull delron/fastdfs</span><br></pre></td></tr></table></figure><p><strong>新建本地tracker和storage目录</strong></p><blockquote><p>E:\dockercontainers\fastdfs\tracker</p><p>E:\dockercontainers\fastdfs\storage</p></blockquote><p><strong>tracker安装</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  --name tracker   --network=ycnetwork     E:\dockercontainers\fastdfs\tracker:/<span class="keyword">var</span>/fdfs delron/fastdfs tracker</span><br></pre></td></tr></table></figure><p><strong>storage安装</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p <span class="number">8888</span>:<span class="number">8888</span> --name storage --network=ycnetwork  -e TRACKER_SERVER=<span class="number">172.18</span><span class="number">.0</span><span class="number">.4</span>:<span class="number">22122</span> -v E:\dockercontainers\fastdfs\storage:/<span class="keyword">var</span>/fdfs -e GROUP_NAME=group1 delron/fastdfs storage</span><br></pre></td></tr></table></figure><h3 id="storage文件上传"><a href="#storage文件上传" class="headerlink" title="storage文件上传"></a>storage文件上传</h3><p>…</p><h3 id="SpringBoot项目上传"><a href="#SpringBoot项目上传" class="headerlink" title="SpringBoot项目上传"></a>SpringBoot项目上传</h3><p><strong>1.导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.luhuiguo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.配置上线项目的application-prod.yaml文件</strong></p><p><span style="color:red">注：redis与mysql地址因与启动容器时docker分配的地址一致</span></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nginx:</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">http://localhost:8888/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#激活文件</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">store-type:</span> <span class="string">redis</span> <span class="comment">#将session保存到redis中</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">1</span> <span class="comment">#redis 默认0-15总共16个库 这里采用1库</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.2</span>  <span class="comment">#到docker后修改，还要加上用户名和密码，且redis中配置访问的主机的ip，以提高安全性</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">a</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://172.18.0.3:3306/134res?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">a</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">org.springframework:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">org.apache:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">logs/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">fdfs:</span></span><br><span class="line">  <span class="comment">#客户端在连接到服务器时的超时时间为2秒</span></span><br><span class="line">  <span class="attr">connect-timeout:</span> <span class="number">2000</span></span><br><span class="line">  <span class="comment">#连接到服务器后的读取数据超时时间为3秒</span></span><br><span class="line">  <span class="attr">so-timeout:</span> <span class="number">3000</span></span><br><span class="line">  <span class="comment">#服务器的地址和端口，与tracker的一致</span></span><br><span class="line">  <span class="attr">tracker-list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.4</span><span class="string">:22122</span></span><br></pre></td></tr></table></figure><p><strong>3.将项目用idea插件推送镜像至docker</strong></p><p><strong>1.pom.xml导入插件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 根据Dockfile文件生成docker镜像   --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>javastack/$&#123;project.name&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dockerfile</span>&gt;</span>Dockerfile<span class="tag">&lt;/<span class="name">dockerfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.配置DockFile文件</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从openjdk的官方镜像仓库中拉取一个OpenJDK 8的镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加参数</span></span><br><span class="line"><span class="keyword">ARG</span> JAR_FILE</span><br><span class="line"></span><br><span class="line"><span class="comment">#将Maven构建生成的JAR文件（由构建参数 JAR_FILE 指定）复制到镜像中的app.jar文件。</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> target/<span class="variable">$&#123;JAR_FILE&#125;</span> app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过 Java 运行 app.jar，并指定了一些 Java 运行参数，如激活名为 prod 的 Spring Profile，并设置随机数种子源为 /dev/./urandom。</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Dspring.profiles.active=prod&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>3.项目打包生成docker镜像</strong></p><p><strong>打包项目自动生成镜像</strong></p><p><img src="/img/docker/package.png"></p><p><strong>docker生成的镜像</strong></p><p><img src="/img/docker/project-image.png"></p><p><strong>4.用镜像生成一个container容器</strong></p><p><img src="/img/docker/project-container.png"></p><p><strong>5.将容器加入birdge网络</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network connect ycnetwork 134res</span><br><span class="line"><span class="comment">//查看网络中是否含有134res容器</span></span><br><span class="line">docker inspect ycnetwork</span><br></pre></td></tr></table></figure><p><img src="/img/docker/project-container_2.png"></p><p>在docker上重新启动134res容器</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/11/01/SpringMVC/"/>
      <url>/2023/11/01/SpringMVC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/10/30/Spring/"/>
      <url>/2023/10/30/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><blockquote><p>Spring 是一个开源的 JavaEE (Java Enterprise Edition) 应用程序开发框架，它提供了一种轻量级的、非侵入式的编程模型，旨在简化企业级Java应用程序的开发。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/10/30/SpringBoot/"/>
      <url>/2023/10/30/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><blockquote><p>Spring Boot 是一个基于 Spring 框架的快速开发框架，旨在简化 Spring 应用程序的搭建和配置过程。它通过提供一种约定优于配置的方式，集成了许多常用的第三方库和工具，使得开发者可以更加专注于业务逻辑的实现，而不需要花费过多精力在繁琐的配置上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-几种Controller测试方法</title>
      <link href="/2023/10/25/SpringBoot%20-%E5%87%A0%E7%A7%8DController%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
      <url>/2023/10/25/SpringBoot%20-%E5%87%A0%E7%A7%8DController%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Swagger测试"><a href="#Swagger测试" class="headerlink" title="Swagger测试"></a>Swagger测试</h2><h3 id="关于Swagger"><a href="#关于Swagger" class="headerlink" title="关于Swagger"></a><strong>关于Swagger</strong></h3><p><img src="/img/SpringBoot/swagger.png" alt="QQ截图20231022200152"></p><p><em><strong>Swagger 简介</strong></em></p><blockquote><p>Swagger 是一个用于设计、构建、文档化和使用 Restful API 的开源框架。它提供了一组工具，包括用于创建 API 规范的 Swagger 编辑器、用于生成 API 客户端代码的 Swagger Codegen，以及用于 API 文档化和测试的 Swagger UI。</p><p>Swagger 的主要目标是简化开发者在构建 API 时的工作流程，并促进不同团队之间的协作。通过使用 Swagger，开发者可以使用简单的 YAML 或 JSON 文件定义 API 的端点、参数、请求和响应体，并基于这些定义生成文档和代码。这样，开发者可以更好地定义 API 的结构和行为，同时也可以为开发者、测试人员和客户提供一个易于理解和使用的接口文档。</p><p>除了 API 定义和文档生成外，Swagger 还提供了一些工具和插件，以帮助开发者自动生成客户端代码、执行自动化测试以及部署和管理 API。</p></blockquote><p><em><strong>Swagger UI</strong></em></p><blockquote><p>Swagger UI 是 Swagger 的一个组件，用于可视化展示和交互式测试 API 的文档。它基于 Swagger 规范生成一个漂亮和功能丰富的用户界面，让开发者能够更好地理解和使用 API。</p><p>使用 Swagger UI，开发者可以直接在浏览器中查看 API 的所有细节，包括端点、请求和响应的参数、数据类型、示例和说明等。Swagger UI 提供了一个交互式的界面，可以方便地构建和发送请求，并查看返回的结果。它还支持代码片段的自动生成，帮助开发者快速集成 API 到他们的应用程序中。</p><p>Swagger UI 的界面简洁明了，页面左侧是 API 的目录结构，右侧则是选中端点后的详细信息，包括请求参数、响应示例和状态码等。用户可以直接在界面上填写参数并发送请求，在页面上获得实时的响应结果。此外，Swagger UI 还支持测试用例的导入和导出，方便与团队成员共享和合作。</p><p>总结来说，Swagger UI 是一个强大的工具，可用于呈现和测试 API 的文档。它提供了一个直观且易于使用的界面，可以帮助开发者更好地理解、交互和测试他们的 API。</p></blockquote><p><strong>swagger测试的缺点</strong></p><p>1.过于繁多的注解给后续的代码维护带来了许多麻烦,如果代码内容发生的变化,注解对应描述内容也要进行修改,如果未及时修改,会造成文档内容不准确,给后续代码的修改带来了许多麻烦.</p><p>2.安全性问题,对于一个网站,该测试方法只需在Web地址后加上<strong>swagger-ui.html</strong>就可以访问到swagger的后台,可以对代码核心内容进行测试查询,将数据库关键信息暴露出来,不利于数据的保护;</p><p>3.运行时性能开销：Swagger 2 的生成过程需要读取和解析源代码，这可能会引入一些运行时的性能开销。尤其是在大型项目中，这可能会对性能产生一定的影响。</p><h3 id="Swagger-快速开始"><a href="#Swagger-快速开始" class="headerlink" title="Swagger 快速开始"></a>Swagger 快速开始</h3><h4 id="配置pom-xml-引入依赖"><a href="#配置pom-xml-引入依赖" class="headerlink" title="配置pom.xml,引入依赖"></a><strong>配置pom.xml,引入依赖</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.spring4all&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">1.9</span><span class="number">.0</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="提供的业务场景"><a href="#提供的业务场景" class="headerlink" title="提供的业务场景"></a><strong>提供的业务场景</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模拟实现一个订餐系统,通过菜品的Id查菜品有关的信息</span><br></pre></td></tr></table></figure><p><strong>entity</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resfood</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer fid;</span><br><span class="line">    <span class="keyword">private</span> String fname;</span><br><span class="line">    <span class="keyword">private</span> Double normprice;</span><br><span class="line">    <span class="keyword">private</span> Double realprice;</span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">    <span class="keyword">private</span> String fphoto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>service层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yc.biz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.yc.bean.Resfood;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResFoodBiz</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//通过菜品的id查询菜品信息</span></span><br><span class="line">    <span class="keyword">public</span> Resfood <span class="title function_">findById</span><span class="params">(Integer fid)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Mapper层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.yc.bean.Resfood;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResFoodMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Resfood&gt; &#123;</span><br><span class="line">    <span class="comment">//利用动态代理根据这个接口的方法啊来生成一个代理对象，并将所有的方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yc.biz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.yc.bean.Resfood;</span><br><span class="line"><span class="keyword">import</span> com.yc.dao.ResFoodMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResFoodBizImpl</span> <span class="keyword">implements</span> <span class="title class_">ResFoodBiz</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResFoodMapper resFoodMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resfood <span class="title function_">findById</span><span class="params">(Integer fid)</span> &#123;</span><br><span class="line">        <span class="type">QueryWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;fid&quot;</span>,fid);</span><br><span class="line">        <span class="type">Resfood</span> <span class="variable">resfood</span> <span class="operator">=</span> resFoodMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">return</span> resfood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Contrller层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yc.bean.Resfood;</span><br><span class="line"><span class="keyword">import</span> com.yc.biz.ResFoodBiz;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/resfood&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span><span class="comment">//生成日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResFoodController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResFoodBiz resFoodBiz;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Resfood <span class="title function_">findById</span><span class="params">(<span class="meta">@RequestParam</span> Integer fid)</span>&#123;</span><br><span class="line">        <span class="type">Resfood</span> <span class="variable">resfood</span> <span class="operator">=</span> resFoodBiz.findById(fid);</span><br><span class="line">        <span class="keyword">return</span> resfood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>  <span class="comment">//开启seagger注解驱动</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yc.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ResApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="swagger注解的使用方法"><a href="#swagger注解的使用方法" class="headerlink" title="swagger注解的使用方法"></a><strong>swagger注解的使用方法</strong></h4><h5 id="Api"><a href="#Api" class="headerlink" title="@Api"></a><strong>@Api</strong></h5><p>@Api 注解用于标注一个Controller（Class）。<br>tags&#x3D;”说明该类的作用，可以在前台界面上看到的注解”<br>value&#x3D;”该参数无意义，在UI界面上看不到，不需要配置”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;ResFoodController&quot;, tags = &quot;菜品的控制层&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResFoodController</span> &#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="ApiOperation"></a><strong>ApiOperation</strong></h5><p>注解在用于对一个操作或HTTP方法进行描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ApiOperation 注解在用于对一个操作或HTTP方法进行描述</span></span><br><span class="line">  <span class="meta">@ApiOperation(&quot;根据菜品id查菜品信息&quot;)</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/findById&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Resfood <span class="title function_">findById</span><span class="params">(</span></span><br><span class="line"><span class="params">          <span class="meta">@RequestParam</span> Integer fid)</span>&#123;</span><br><span class="line">      <span class="type">Resfood</span> <span class="variable">resfood</span> <span class="operator">=</span> resFoodBiz.findById(fid);</span><br><span class="line">      <span class="keyword">return</span> resfood;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="ApiParam"><a href="#ApiParam" class="headerlink" title="@ApiParam"></a><strong>@ApiParam</strong></h5><p>用在参数列表的请求参数前面,对参数进行描述或说明是否为必添项等说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Resfood <span class="title function_">findById</span><span class="params">(</span></span><br><span class="line"><span class="params">           <span class="meta">@ApiParam(name = &quot;fid&quot;,value = &quot;菜品的id号&quot;)</span></span></span><br><span class="line"><span class="params">           <span class="meta">@RequestParam</span> Integer fid)</span></span><br></pre></td></tr></table></figure><h5 id="ApiImplicitParam"><a href="#ApiImplicitParam" class="headerlink" title="@ApiImplicitParam"></a><strong>@ApiImplicitParam</strong></h5><p><strong>@ApiImplicitParams</strong>：⽤在⽅法上包含⼀组参数说明</p><p><strong>@ApiImplicitParam</strong>：⽤在@ApiImplicitParams注解中,指定一个请求参数的各个方面</p><ul><li><p>name: 参数名</p></li><li><p>value: 参数的说明、解释</p></li><li><p>required: 是否必须传参</p></li><li><p>paramType：参数放什么位置</p><blockquote><p>path: 以地址的形式提交数据</p><p>query: 直接跟参数完成⾃动映射赋值</p><p>body: 以流的形式提交  仅⽀持POST</p><p>header: 参数在request headers⾥边提交</p><p>form: 以form表单的形式提交仅⽀持POST</p></blockquote></li><li><p>dataType: 参数类型，默认String,其它值dataType&#x3D;”Integer”</p></li><li><p>defaultValue: 参数的默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiImplicitParams(</span></span><br><span class="line"><span class="meta">         @ApiImplicitParam(</span></span><br><span class="line"><span class="meta">                 name = &quot;fid&quot;,</span></span><br><span class="line"><span class="meta">                 value = &quot;菜品的id号2&quot;,</span></span><br><span class="line"><span class="meta">                 paramType = &quot;query&quot;,</span></span><br><span class="line"><span class="meta">                 dataType = &quot;Integer&quot;</span></span><br><span class="line"><span class="meta">         )</span></span><br><span class="line"><span class="meta"> )</span></span><br><span class="line"> <span class="keyword">public</span> Resfood <span class="title function_">findById</span><span class="params">( ... )</span>&#123;</span><br><span class="line">     . . .</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><font color=Red>注: @ApiImplicitParams 与 @ApiParam 同时使用时 前者的优先级会高于后者并将其覆盖掉</font></p><p><strong>swagger-ui上的效果</strong></p><p><img src="/img/SpringBoot/swagger-ApiImplicitParam1.png"></p><p><strong>点击Try it out,并输入你要查询的菜品id,最后点击Execte按钮就可以看到结果了</strong></p><p><img src="/img/SpringBoot/swagger-ApiImplicitparam2.png"></p><h5 id="ApiModel"><a href="#ApiModel" class="headerlink" title="ApiModel"></a><strong>ApiModel</strong></h5><p><strong>@ApiModel: 用在响应类上，表示一个返回响应数据的信息</strong></p><p>**@ApiModelProerty:用在属性上，面熟响应类的属性*</p><ul><li>一般用在post 创建，使用@RequestBody的时候</li><li>请求参数无法使用@ApiImplicitParam</li></ul><blockquote><p>@ApiModel注解是用在接口相关的实体类上的注解，它主要是用来对使用该注解的接口相关的实体类添加额外的描述信息，常常和@ApiModelProperty注解配合使用</p><p>@ApiModelProperty注解则是作用在接口相关实体类的属性（字段）上的注解，用来对具体的接口相关实体类中的参数添加额外的描述信息，除了可以和 @ApiModel 注解关联使用，也会单独拿出来用。</p><p>作用域不同，@ApiModel作用在类上，@ApiModel作用来属性上</p></blockquote><p><strong>ApiModelProperty属性：</strong>value、name、required 、hidden、allowEmptyValue、hidden、dataType、example</p><p><strong>allowEmptyValue：</strong> 用来描述实体参数的值是否可以为空值。在 ApiModelProperty 注解中直接声明 allowEmptyValue属性的值即可，如果不声明该属性，则默认为false，即字段参数的值不可以为空。</p><p><strong>hidden：</strong> 用来描述实体中参数字段是否显示在Swagger界面中，默认也是false，true表示隐藏。</p><p><strong>example：</strong> </p><p>在<code>@ApiModelProperty</code>注解中，<code>example</code>属性用于提供属性的示例值，以帮助用户理解和使用该属性。</p><p>例如，考虑以下模型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(example = &quot;John Doe&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(example = &quot;john.doe@example.com&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>@ApiModelProperty</code>注解用于<code>name</code>和<code>email</code>属性，分别使用<code>example</code>属性指定了示例值。这些示例值可以是任何合法的属性值，用于说明属性的预期内容。</p><p>当使用此模型类生成API文档或进行验证时，示例值将被显示或用于验证输入。例如，如果使用Swagger生成API文档，示例值将在属性描述中显示出来，以帮助用户了解属性的期望格式和值。</p><p>总之，<code>@ApiModelProperty</code>中的<code>example</code>属性用于提供属性的示例值，以便在生成文档或进行验证时使用。</p><p><strong>在swagger-ui中的呈现效果:</strong></p><p><strong>示例代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;Resfood&quot;,description = &quot;菜品实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resfood</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(name=&quot;fid&quot;,value = &quot;菜品id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer fid;</span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;fname&quot;,value = &quot;菜品名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fname;</span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;normprice&quot;,value = &quot;原件&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double normprice;</span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;realprice&quot;,value = &quot;真实价&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double realprice;</span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;detail&quot;,value = &quot;细节描述&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;fphoto&quot;,value = &quot;图片&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fphoto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/SpringBoot/swagger-Model.png"></p><h2 id="postman测试"><a href="#postman测试" class="headerlink" title="postman测试"></a>postman测试</h2><h3 id="软件简介"><a href="#软件简介" class="headerlink" title="软件简介"></a>软件简介</h3><blockquote><p>Postman是一个接口测试工具,在做接口测试的时候,Postman相当于一个客户端,它可以模拟用户发起的各类HTTP请求,将请求数据发送至服务端,获取对应的响应结果, 从而验证响应中的结果数据是否和预期值相匹配;并确保开发人员能够及时处理接口中的bug,进而保证产品上线之后的稳定性和安全性。 它主要是用来模拟各种HTTP请求的(如:get&#x2F;post&#x2F;delete&#x2F;put..等等),Postman与浏览器的区别在于有的浏览器不能输出Json格式,而Postman更直观接口返回的结果。</p></blockquote><p>官方下载地址: </p><p><a href="https://www.postman.com/downloads/" target="_blank">postman</a></p><h3 id="postman快速开始"><a href="#postman快速开始" class="headerlink" title="postman快速开始"></a>postman快速开始</h3><p><img src="/img/SpringBoot/postman-test.png"></p><h2 id="Mock测试-模拟Web-容器环境"><a href="#Mock测试-模拟Web-容器环境" class="headerlink" title="Mock测试 -&gt; 模拟Web 容器环境"></a>Mock测试 -&gt; 模拟Web 容器环境</h2><h3 id="什么是Mock"><a href="#什么是Mock" class="headerlink" title="什么是Mock ?"></a>什么是Mock ?</h3><blockquote><p>在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。</p></blockquote><h3 id="为什么使用Mock对象"><a href="#为什么使用Mock对象" class="headerlink" title="为什么使用Mock对象 ?"></a>为什么使用Mock对象 ?</h3><blockquote><p>使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。</p></blockquote><h3 id="什么是MockMVC"><a href="#什么是MockMVC" class="headerlink" title="什么是MockMVC ?"></a>什么是MockMVC ?</h3><blockquote><p>MockMvc 是 SpringFramework 中的一个测试工具，用于模拟 HTTP 请求和响应的行为。MockMvc 可以模拟发送 GET、POST、PUT、DELETE 等 HTTP 请求，并验证响应的状态码、内容类型和响应体等。</p></blockquote><h3 id="Mock-快速开始"><a href="#Mock-快速开始" class="headerlink" title="Mock  快速开始"></a>Mock  快速开始</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    表示你的项目继承自这个 starter-parent: 项目依赖信息</span><br><span class="line">        依赖仲裁</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.7</span><span class="number">.16</span>&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    </span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h4 id="启用MockMvc"><a href="#启用MockMvc" class="headerlink" title="启用MockMvc"></a>启用MockMvc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在测试类中添加 @SpringBootTest 和 @AutoConfigureMockMvc 注释启用 MockMvc。</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = ResApp.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResAppTest</span> &#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注入MockMvc对象"><a href="#注入MockMvc对象" class="headerlink" title="注入MockMvc对象"></a>注入MockMvc对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mockMvc;</span><br></pre></td></tr></table></figure><h4 id="模拟Http请求"><a href="#模拟Http请求" class="headerlink" title="模拟Http请求"></a>模拟Http请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 MockMvc 对象的 perform 方法模拟 HTTP 请求。</span></span><br><span class="line"><span class="comment">//请求路径为 “/food/findByFid”</span></span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/resfood/findById&quot;</span>)</span><br><span class="line">                 <span class="comment">//设置请求的参数</span></span><br><span class="line">                .param(<span class="string">&quot;fid&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                *将请求的 Content-Type 设置为 application/json，</span></span><br><span class="line"><span class="comment">                *表示请求正文的内容为 JSON 格式。*/</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h4 id="验证响应状态码、内容、响应体"><a href="#验证响应状态码、内容、响应体" class="headerlink" title="验证响应状态码、内容、响应体"></a>验证响应状态码、内容、响应体</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//期望返回的 HTTP 状态码为 200。</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                <span class="comment">//期望返回的结果中，属性 data.fname 的值与预期的 resfood.getFname() 相等，忽略大小写。</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.data.fname&quot;</span>, Matchers.equalToIgnoringCase(resfood.getFname())))</span><br><span class="line">                <span class="comment">//使用 andExpect 方法验证响应的内容类型</span></span><br><span class="line">                .andExpect(content().contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">                <span class="comment">//在控制台打印请求和响应的详细信息。</span></span><br><span class="line">                .andDo(print())</span><br><span class="line">                <span class="comment">//返回执行结果。</span></span><br><span class="line">                .andReturn();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mq</title>
      <link href="/2023/04/01/MQ%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/04/01/MQ%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式，为什么呢？</p><p>我们先来看看什么是同步通讯和异步通讯。如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1686983181054-f2bcce85-1fce-412f-95cd-1ae829f8406f.png#averageHue=%239dce6d&clientId=uf9c47826-2719-4&from=paste&height=613&id=u84c8f02e&originHeight=760&originWidth=1695&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=112976&status=done&style=none&taskId=u779e4d59-c9a8-4b1f-a49f-59c578c4ccd&title=&width=1367.3949141495996" alt="image.png"><br>解读：</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><p>所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。</p><p>同步调用的方式我们已经学过了，之前的OpenFeign调用就是。但是：</p><ul><li>异步调用又该如何实现？</li><li>哪些业务适合用异步调用来实现呢？</li></ul><p>通过今天的学习你就能明白这些问题了。</p><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步调用"><a href="#1-1-同步调用" class="headerlink" title="1.1.同步调用"></a>1.1.同步调用</h2><p>之前说过，我们现在基于OpenFeign的调用都属于是同步调用，那么这种方式存在哪些问题呢？<br>举个例子，我们以昨天留给大家作为作业的<strong>余额支付功能</strong>为例来分析，首先看下整个流程：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989758652-29a64761-c029-4ec4-91aa-f1fc85de086c.jpeg"><br>目前我们采用的是基于OpenFeign的同步调用，也就是说业务执行流程是这样的：</p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行。<br>这其中就存在3个问题：<br><strong>第一</strong>，<strong>拓展性差</strong><br>我们目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。<br>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？<br>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？<br>。。。<br>最终你的支付业务会越来越臃肿：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686984472076-c05b2155-3346-40f5-b85e-5961caa998ab.jpeg"><br>也就是说每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</p><p><strong>第二</strong>，<strong>性能下降</strong><br>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989760653-42e1ae3e-677b-4f27-b55a-eaa259f03ad3.jpeg"><br>假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。</p><p><strong>第三，级联失败</strong><br>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。<br>这其实就是同步调用的<strong>级联失败</strong>问题。</p><p>但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧<img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1686986652875-9e2924a9-e0f3-4de2-ae41-8b39ef6345bc.png#averageHue=%23d2c088&clientId=uf9c47826-2719-4&from=paste&height=22&id=u1eecfdc1&originHeight=143&originWidth=150&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=42199&status=done&style=none&taskId=u80811df5-062e-457a-a9a8-0173e00f6b1&title=&width=22.999998092651367" alt="image.png">。</p><p>因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。</p><p>综上，同步调用的方式存在下列问题：</p><ul><li>拓展性差</li><li>性能下降</li><li>级联失败</li></ul><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h2 id="1-2-异步调用"><a href="#1-2-异步调用" class="headerlink" title="1.2.异步调用"></a>1.2.异步调用</h2><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686990662733-65b0eac8-f65f-4024-a581-6d5761c4c5a4.jpeg"></p><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。<br>这样，发送消息的人和接收消息的人就完全解耦了。</p><p>还是以余额支付业务为例：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686990257816-4f0b5ddd-7618-4095-b797-25b92f0bf2a5.jpeg"><br>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>假如产品经理提出了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989956210-7c1f451c-0368-4602-b02e-a66f2c0f6deb.jpeg"><br>不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。</p><p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。</p><p>综上，异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h2 id="1-3-技术选型"><a href="#1-3-技术选型" class="headerlink" title="1.3.技术选型"></a>1.3.技术选型</h2><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.<br>目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br>追求可靠性：RabbitMQ、RocketMQ<br>追求吞吐能力：RocketMQ、Kafka<br>追求消息低延迟：RabbitMQ、Kafka</p><p>据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此我们课堂上选择RabbitMQ来学习。</p><h1 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h1><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：<br><a href="https://www.rabbitmq.com/">Messaging that just works — RabbitMQ</a><br>接下来，我们就学习它的基本概念和基础用法。</p><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1.安装"></a>2.1.安装</h2><p>我们同样基于Docker来安装RabbitMQ，使用下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hmall \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>如果拉取镜像困难的话，可以使用课前资料给大家准备的镜像，利用docker load命令加载：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689939432832-7ee45271-f96c-43fa-b0f5-8c01bcdf289f.png#averageHue=%23f8f2f2&clientId=uf6195e90-5366-4&from=paste&height=169&id=u6c039f48&originHeight=188&originWidth=747&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=15874&status=done&style=none&taskId=ub0c7a06c-2f63-4bc5-98d6-da0bfc75c32&title=&width=669.5798176232812" alt="image.png"></p><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问 <a href="http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。">http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</a><br>登录后即可看到管理控制台总览页面：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687137883587-56417f79-a649-43a5-be88-2ff777d3cd25.png#averageHue=%23f7f6f6&clientId=u6a529863-cf4b-4&from=paste&height=707&id=u7d848ee1&originHeight=876&originWidth=1572&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=83168&status=done&style=none&taskId=ub505f8cf-075f-462b-bce3-e0df935715d&title=&width=1268.168026574142" alt="image.png"></p><p>RabbitMQ对应的架构如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687136827222-52374724-79c9-4738-b53f-653cc0805d22.png#averageHue=%23e8d7b3&clientId=u6a529863-cf4b-4&from=paste&height=495&id=ub8dd8df6&originHeight=614&originWidth=1458&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=104273&status=done&style=none&taskId=uc0c132a5-73a3-4024-819f-61241da2511&title=&width=1176.2016429676203" alt="image.png"><br>其中包含几个概念：</p><ul><li><code>**publisher**</code>：生产者，也就是发送消息的一方</li><li><code>**consumer**</code>：消费者，也就是消费消息的一方</li><li><code>**queue**</code>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><code>**exchange**</code>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><code>**virtual host**</code>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>上述这些东西都可以在RabbitMQ的管理控制台来管理，下一节我们就一起来学习控制台的使用。</p><h2 id="2-2-收发消息"><a href="#2-2-收发消息" class="headerlink" title="2.2.收发消息"></a>2.2.收发消息</h2><h3 id="2-2-1-交换机"><a href="#2-2-1-交换机" class="headerlink" title="2.2.1.交换机"></a>2.2.1.交换机</h3><p>我们打开Exchanges选项卡，可以看到已经存在很多交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687137953880-08aa9694-6a1e-4337-8bde-5757ec3c33f8.png#averageHue=%23f7f6f6&clientId=u6a529863-cf4b-4&from=paste&height=605&id=u413741e2&originHeight=750&originWidth=1264&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=60217&status=done&style=none&taskId=u8611b86c-aa50-46d9-855f-8307a318079&title=&width=1019.6974463038903" alt="image.png"><br>我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138031622-ccce4612-954f-42c0-9291-73cf19915e39.png#averageHue=%23f9f8f7&clientId=u6a529863-cf4b-4&from=paste&height=487&id=u9d211d96&originHeight=604&originWidth=947&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=38263&status=done&style=none&taskId=ue134ec0e-ad83-465f-a1b2-97cb7667d75&title=&width=763.9663620647026" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138163403-839087fe-66f7-4710-a866-210aa0282be8.png#averageHue=%23f9f6f6&clientId=u6a529863-cf4b-4&from=paste&height=616&id=ubca84480&originHeight=763&originWidth=1092&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46085&status=done&style=none&taskId=u5f176fff-eda8-457c-94cd-bb7d6bbd997&title=&width=880.9411482308925" alt="image.png"><br>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><h3 id="2-2-2-队列"><a href="#2-2-2-队列" class="headerlink" title="2.2.2.队列"></a>2.2.2.队列</h3><p>我们打开<code>Queues</code>选项卡，新建一个队列：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138308409-be6e1649-af03-4ee7-bee3-8518fd0dca03.png#averageHue=%23f9f8f7&clientId=u6a529863-cf4b-4&from=paste&height=417&id=u398bfe43&originHeight=517&originWidth=1157&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35084&status=done&style=none&taskId=u3b2b568c-e113-4abf-971c-2aea7bfaa4b&title=&width=933.3781213398743" alt="image.png"><br>命名为<code>hello.queue1</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255044231-4b0e0339-c1ab-468a-8a72-9ae1b184594c.png#averageHue=%23f9f6f6&clientId=u1711eaf3-9387-4&from=paste&height=548&id=uf3cb4af4&originHeight=679&originWidth=1163&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=51428&status=done&style=none&taskId=u71f9590b-0cc5-4727-bd4c-65b353c4df7&title=&width=938.2184573191648" alt="image.png"><br>再以相同的方式，创建一个队列，密码为<code>hello.queue2</code>，最终队列列表如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255204405-523f8053-e414-45f3-99c3-b66de152f79e.png#averageHue=%23f6f5f4&clientId=u1711eaf3-9387-4&from=paste&height=359&id=u956d1947&originHeight=445&originWidth=1074&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=39049&status=done&style=none&taskId=u1eb8bf9f-f74b-4238-a33e-796c4280e78&title=&width=866.4201402930207" alt="image.png"><br>此时，我们再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！<br>怎么回事呢？<br>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><h3 id="2-2-3-绑定关系"><a href="#2-2-3-绑定关系" class="headerlink" title="2.2.3.绑定关系"></a>2.2.3.绑定关系</h3><p>点击<code>Exchanges</code>选项卡，点击<code>amq.fanout</code>交换机，进入交换机详情页，然后点击<code>Bindings</code>菜单，在表单中填写要绑定的队列名称：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255547460-d87943cd-4309-4778-8e9e-374167a97e45.png#averageHue=%23f9f7f7&clientId=u1711eaf3-9387-4&from=paste&height=481&id=u04a61731&originHeight=596&originWidth=1022&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=34676&status=done&style=none&taskId=u0ce69958-400b-4c37-89ea-adf0b369080&title=&width=824.4705618058354" alt="image.png"><br>相同的方式，将hello.queue2也绑定到改交换机。<br>最终，绑定结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255624712-7bd850b1-95fd-4d98-8243-57d1779de935.png#averageHue=%23f7f4f4&clientId=u1711eaf3-9387-4&from=paste&height=385&id=u82198db4&originHeight=477&originWidth=978&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=28098&status=done&style=none&taskId=u1394f18f-c109-4688-9eb1-effec6a43fb&title=&width=788.9747646243708" alt="image.png"></p><h3 id="2-2-4-发送消息"><a href="#2-2-4-发送消息" class="headerlink" title="2.2.4.发送消息"></a>2.2.4.发送消息</h3><p>再次回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，点击进入详情页，再次发送一条消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138163403-839087fe-66f7-4710-a866-210aa0282be8.png#averageHue=%23f9f6f6&clientId=u6a529863-cf4b-4&from=paste&height=616&id=GyhjT&originHeight=763&originWidth=1092&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46085&status=done&style=none&taskId=u5f176fff-eda8-457c-94cd-bb7d6bbd997&title=&width=880.9411482308925" alt="image.png"><br>回到<code>Queues</code>页面，可以发现<code>hello.queue</code>中已经有一条消息了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255725782-fd5e2550-3572-48c0-9ec0-60786e33a3b1.png#averageHue=%23f5f4f3&clientId=u1711eaf3-9387-4&from=paste&height=319&id=u97a4707c&originHeight=395&originWidth=1051&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=38484&status=done&style=none&taskId=u4d68c013-3032-4d2b-83a0-571c3335780&title=&width=847.8655190390733" alt="image.png"><br>点击队列名称，进入详情页，查看队列详情，这次我们点击get message：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255765034-69e67460-1535-48b3-8537-da383c498141.png#averageHue=%23f8f7f7&clientId=u1711eaf3-9387-4&from=paste&height=473&id=ua850c29b&originHeight=586&originWidth=974&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35281&status=done&style=none&taskId=u668d2c9f-54a9-4427-adc4-e121a960025&title=&width=785.7478739715103" alt="image.png"><br>可以看到消息到达队列了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255798153-dda9b729-a3a0-415c-9167-48c525c75800.png#averageHue=%23f9f7f7&clientId=u1711eaf3-9387-4&from=paste&height=466&id=u66fa5450&originHeight=578&originWidth=762&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=33500&status=done&style=none&taskId=u665361c6-23b2-4fc4-b1a9-fdf6c880545&title=&width=614.7226693699085" alt="image.png"><br>这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</p><h2 id="2-3-数据隔离"><a href="#2-3-数据隔离" class="headerlink" title="2.3.数据隔离"></a>2.3.数据隔离</h2><h3 id="2-3-1-用户管理"><a href="#2-3-1-用户管理" class="headerlink" title="2.3.1.用户管理"></a>2.3.1.用户管理</h3><p>点击<code>Admin</code>选项卡，首先会看到RabbitMQ控制台的用户管理界面：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151143347-f7e2aaff-0a14-4022-8d50-582ee75e2998.png#averageHue=%23f7f5f5&clientId=uc5430584-57f9-4&from=paste&height=450&id=u2a51a990&originHeight=558&originWidth=1580&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=55212&status=done&style=none&taskId=u18a12c4e-be8d-4ccb-a14a-415a21db44a&title=&width=1274.621807879863" alt="image.png"><br>这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的<code>itheima</code>这个用户。仔细观察用户表格中的字段，如下：</p><ul><li><code>Name</code>：<code>itheima</code>，也就是用户名</li><li><code>Tags</code>：<code>administrator</code>，说明<code>itheima</code>用户是超级管理员，拥有所有权限</li><li><code>Can access virtual host</code>： <code>/</code>，可以访问的<code>virtual host</code>，这里的<code>/</code>是默认的<code>virtual host</code></li></ul><p>对于小型企业而言，出于成本考虑，我们通常只会搭建一套MQ集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</li></ul><p>比如，我们给黑马商城创建一个新的用户，命名为<code>hmall</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151725993-05fe9bd1-8f8b-468d-8456-eac36278bea2.png#averageHue=%23f7f5f5&clientId=uc5430584-57f9-4&from=paste&height=609&id=ua32ca0ae&originHeight=755&originWidth=1569&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=70298&status=done&style=none&taskId=u4f4ed00c-b8dd-4ffd-8a83-75d03c11fb5&title=&width=1265.7478585844967" alt="image.png"><br>你会发现此时hmall用户没有任何<code>virtual host</code>的访问权限：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151853554-e671a696-e9c0-4ff5-9caf-31b39e1a17f5.png#averageHue=%23f7f5f4&clientId=uc5430584-57f9-4&from=paste&height=353&id=ueeaf90c6&originHeight=437&originWidth=927&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=31497&status=done&style=none&taskId=u74d79385-5602-447d-8beb-ed20ec36022&title=&width=747.8319088004005" alt="image.png"><br>别急，接下来我们就来授权。</p><h3 id="2-3-2-virtual-host"><a href="#2-3-2-virtual-host" class="headerlink" title="2.3.2.virtual host"></a>2.3.2.virtual host</h3><p>我们先退出登录：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152245922-8438490f-d094-4db1-88fa-a2d916d46a97.png#averageHue=%23f6f5f5&clientId=uc5430584-57f9-4&from=paste&height=374&id=u12c0492e&originHeight=463&originWidth=1571&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=50699&status=done&style=none&taskId=u830f1745-a0ed-4202-9849-7653ebae4c2&title=&width=1267.3613039109268" alt="image.png"><br>切换到刚刚创建的hmall用户登录，然后点击<code>Virtual Hosts</code>菜单，进入<code>virtual host</code>管理页：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152310566-2531b1c8-b362-47c7-ba81-1b7c1880c18b.png#averageHue=%23f5f4f3&clientId=uc5430584-57f9-4&from=paste&height=409&id=uf51820c2&originHeight=507&originWidth=1565&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=60462&status=done&style=none&taskId=ud7655191-c9d5-4801-9669-55b47348861&title=&width=1262.5209679316363" alt="image.png"><br>可以看到目前只有一个默认的<code>virtual host</code>，名字为 <code>/</code>。<br> 我们可以给黑马商城项目创建一个单独的<code>virtual host</code>，而不是使用默认的<code>/</code>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152363999-edb47263-f303-4ee8-a80d-be55d6b0ed37.png#averageHue=%23f6f5f4&clientId=uc5430584-57f9-4&from=paste&height=553&id=ufc5bd4a7&originHeight=685&originWidth=1555&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=67199&status=done&style=none&taskId=u38a5fe38-fcb5-4163-bee4-ddffaba416b&title=&width=1254.4537412994853" alt="image.png"><br>创建完成后如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152448758-d0a05827-10ac-459b-a92f-495304dddf89.png#averageHue=%23f5f5f4&clientId=uc5430584-57f9-4&from=paste&height=232&id=ue38b9ba4&originHeight=287&originWidth=990&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=24622&status=done&style=none&taskId=ue5f326dc-340c-46e0-83d5-84a19fef1d9&title=&width=798.655436582952" alt="image.png"><br>由于我们是登录<code>hmall</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/hmall</code>这个<code>virtual host</code>的访问权限了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152695194-6c2dda94-43c4-4ee9-b95c-ca9d8504cd0c.png#averageHue=%23f7f4f4&clientId=ud5bd9b1f-141b-4&from=paste&height=349&id=u0cf22cf3&originHeight=432&originWidth=890&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=30925&status=done&style=none&taskId=u1b04bdb9-ab59-41d9-b2bb-e5f5a0cca59&title=&width=717.9831702614417" alt="image.png"></p><p>此时，点击页面右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/hmall</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687153236457-ca138f25-b351-4095-8855-aa0df42fae65.png#averageHue=%23f7f5f4&clientId=ud5bd9b1f-141b-4&from=paste&height=223&id=u0989d284&originHeight=277&originWidth=1448&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35060&status=done&style=none&taskId=u6ab4f38a-ad0d-48bd-ace7-7f0281755d1&title=&width=1168.1344163354693" alt="image.png"><br>然后再次查看queues选项卡，会发现之前的队列已经看不到了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687153307085-0157ac47-2d89-4f32-ab9a-d513b0e19f25.png#averageHue=%23f9f6f6&clientId=ud5bd9b1f-141b-4&from=paste&height=431&id=u151b88b9&originHeight=534&originWidth=1443&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48526&status=done&style=none&taskId=u7ef6af14-7e3c-4988-8721-80965a310f6&title=&width=1164.1008030193937" alt="image.png"><br>这就是基于<code>virtual host </code>的隔离效果。</p><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。<br>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<br><a href="https://spring.io/projects/spring-amqp">Spring AMQP</a><br>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><p>这一章我们就一起学习一下，如何利用SpringAMQP实现对RabbitMQ的消息收发。</p><h2 id="3-1-导入Demo工程"><a href="#3-1-导入Demo工程" class="headerlink" title="3.1.导入Demo工程"></a>3.1.导入Demo工程</h2><p>在课前资料给大家提供了一个Demo工程，方便我们学习SpringAMQP的使用：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689939402093-e0e0a3d4-84ed-40b5-bedc-0884fcb4ae64.png#averageHue=%23f9f9f8&clientId=uf6195e90-5366-4&from=paste&height=169&id=u1dad7a09&originHeight=188&originWidth=752&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=15464&status=done&style=none&taskId=u1668b30b-b977-4fc3-89ba-6c2e029e374&title=&width=674.0616102445883" alt="image.png"><br>将其复制到你的工作空间，然后用Idea打开，项目结构如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687156248415-3fe7ae5b-302b-4a35-a520-b2419e616862.png#averageHue=%23f9fbf8&clientId=ud5bd9b1f-141b-4&from=paste&height=253&id=u53ed8a5e&originHeight=314&originWidth=664&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=30988&status=done&style=none&taskId=u5ab16e5b-840d-4511-b27b-07f42a60f4c&title=&width=535.6638483748284" alt="image.png"><br>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>在mq-demo这个父工程中，已经配置好了SpringAMQP相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mq-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>publisher<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，子工程中就可以直接使用SpringAMQP了。</p><h2 id="3-2-快速入门"><a href="#3-2-快速入门" class="headerlink" title="3.2.快速入门"></a>3.2.快速入门</h2><p>在之前的案例中，我们都是经过交换机发送消息到队列，不过有时候为了测试方便，我们也可以直接向队列发送消息，跳过交换机。<br>在入门案例中，我们就演示这样的简单模型，如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687261777988-23fff732-dcfa-499a-a8a1-a66328fe05e7.jpeg"><br>也就是：</p><ul><li>publisher直接发送消息到队列</li><li>消费者监听并处理队列中的消息</li></ul><p>:::warning<br><strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。<br>:::</p><p>为了方便测试，我们现在控制台新建一个队列：simple.queue<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687171932026-33eace5d-c0f2-4070-8742-fe8b34c6c749.png#averageHue=%23f9f8f8&clientId=u0fe93ba5-a0ba-4&from=paste&height=602&id=uec08e673&originHeight=746&originWidth=1219&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=53932&status=done&style=none&taskId=ubdce29f2-6d3c-45cc-8b7f-64627bcf68c&title=&width=983.3949264592106" alt="image.png"><br>添加成功：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687172012283-e19d8da6-8944-4f51-a40b-a15f0814b015.png#averageHue=%23f7f6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=405&id=u61761e6f&originHeight=502&originWidth=1187&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=40787&status=done&style=none&taskId=uaf3c44d8-727d-4f46-8ae6-46245932d99&title=&width=957.5798012363273" alt="image.png"><br>接下来，我们就可以利用Java代码收发消息了。</p><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在<code>publisher</code>服务的<code>application.yml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，并利用<code>RabbitTemplate</code>实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.amqp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开控制台，可以看到消息已经发送到队列中：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687173164620-51a78ccb-b2a1-474b-8147-076f4b8cee12.png#averageHue=%23f8f7f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=431&id=u34a6c895&originHeight=534&originWidth=1267&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=43690&status=done&style=none&taskId=u6fd3cf33-b6c0-42a6-91f3-e263e176174&title=&width=1022.1176142935356" alt="image.png"><br>接下来，我们再来实现消息接收。</p><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line"><span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687173574481-792b9a3c-bcab-4f96-9d09-206cccdd1456.png#averageHue=%23f7f9f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=405&id=ua133b5cf&originHeight=502&originWidth=1805&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=226083&status=done&style=none&taskId=u72073b8f-ef3f-4ec4-af3e-4187138ca2a&title=&width=1456.134407103261" alt="image.png"></p><h2 id="3-3-WorkQueues模型"><a href="#3-3-WorkQueues模型" class="headerlink" title="3.3.WorkQueues模型"></a>3.3.WorkQueues模型</h2><p>Work queues，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687261956699-4b3c9999-ee86-4dda-a795-1ea5f4f9eef3.jpeg"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>接下来，我们就来模拟这样的场景。<br>首先，我们在控制台创建一个新的队列，命名为<code>work.queue</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687179664222-3e226588-63e3-4275-a9e2-cce5c8e93d4c.png#averageHue=%23f5f2f1&clientId=u0fe93ba5-a0ba-4&from=paste&height=321&id=u96998af1&originHeight=398&originWidth=1180&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=41883&status=done&style=none&taskId=ubcca08d6-3211-435a-ae7c-10fcf4daafe&title=&width=951.9327425938216" alt="image.png"></p><h3 id="3-3-1-消息发送"><a href="#3-3-1-消息发送" class="headerlink" title="3.3.1.消息发送"></a>3.3.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。<br>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-消息接收"><a href="#3-3-2-消息接收" class="headerlink" title="3.3.2.消息接收"></a>3.3.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这两消费者，都设置了<code>Thead.sleep</code>，模拟任务耗时：</p><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3.测试"></a>3.3.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br>最终结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.869555300</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.884518</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.907454400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.953332100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.997867300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.042178700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.086478800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.087476600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.132578300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.175851200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.218533400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.261322900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.287003700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.304412400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.349950100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.394533900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.439876500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.482937800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.488977100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.526409300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.572148</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.618264800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.660780600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.689189300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.705261</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.746927300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.789835</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.834393100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.875312100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.889969500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.920702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.090725900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.293060600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.493748</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.696635100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.896809700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.099533400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.301446400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.504999100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.705702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.906601200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.108118500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.308945400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.511547700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.714038400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.916192700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.116286400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.318055100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.520656400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.723106700</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到消费者1和消费者2竟然每人消费了25条消息：</p><ul><li>消费者1很快完成了自己的25条消息</li><li>消费者2却在缓慢的处理自己的25条消息。</li></ul><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒。这样显然是有问题的。</p><h3 id="3-3-4-能者多劳"><a href="#3-3-4-能者多劳" class="headerlink" title="3.3.4.能者多劳"></a>3.3.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>再次测试，发现结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.659664200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.680610</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.703625</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.724330100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.746651100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.768401400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.790511400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.812559800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.834500600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.857438800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.880379600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.899327100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.922828400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.945617400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.968942500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.992215400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.013325600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.035687100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.058188</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.081208400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.103406200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.123827300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.146165100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.168828300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.191769500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.214839100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.238998700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.259772600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.284131800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.306190600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.325315800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.347012500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.368508600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.391785100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.416383800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.439019</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.461733900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.485990</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.509219900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.523683400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.547412100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.571191800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.593024600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.616731800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.640317</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.663111100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.686727</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.709266500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.725884900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.746299900</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。<br>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h3 id="3-3-5-总结"><a href="#3-3-5-总结" class="headerlink" title="3.3.5.总结"></a>3.3.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-4-交换机类型"><a href="#3-4-交换机类型" class="headerlink" title="3.4.交换机类型"></a>3.4.交换机类型</h2><p>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687264784359-de7cbc4a-ec60-461d-a6a4-3474ba52e0d0.jpeg"><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><p>课堂中，我们讲解前面的三种交换机模式。</p><h2 id="3-5-Fanout交换机"><a href="#3-5-Fanout交换机" class="headerlink" title="3.5.Fanout交换机"></a>3.5.Fanout交换机</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br>在广播模式下，消息发送流程是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687181415478-ea4bb17b-48bf-4303-9242-27703efb39d8.png#averageHue=%23fbf6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=389&id=u41b3ec34&originHeight=482&originWidth=1598&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=84491&status=done&style=none&taskId=u0db849d5-c734-41f3-87c2-d1fe9ec7575&title=&width=1289.1428158177346" alt="image.png"></p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182474076-2b479229-56a6-4163-93c4-a6a7187f3dbe.png#averageHue=%23f9f4f4&clientId=u0fe93ba5-a0ba-4&from=paste&height=248&id=ue59e0d8c&originHeight=308&originWidth=1314&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48827&status=done&style=none&taskId=u7d52896e-f59b-494d-bb25-b376c96414e&title=&width=1060.0335794646453" alt="image.png"></p><ul><li>创建一个名为<code> hmall.fanout</code>的交换机，类型是<code>Fanout</code></li><li>创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，绑定到交换机<code>hmall.fanout</code></li></ul><h3 id="3-5-1-声明队列和交换机"><a href="#3-5-1-声明队列和交换机" class="headerlink" title="3.5.1.声明队列和交换机"></a>3.5.1.声明队列和交换机</h3><p>在控制台创建队列<code>fanout.queue1</code>:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689946886137-0bcb8641-faf1-4bea-b553-4b3bb96d224c.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=380&id=ub435a220&originHeight=424&originWidth=1117&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=31069&status=done&style=none&taskId=uf02d05dd-b916-4d37-b2f4-dba06eff8a9&title=&width=1001.2324716000069" alt="image.png"><br>在创建一个队列<code>fanout.queue2</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689946949922-c4e442c3-568b-4164-a327-74e30aa9b9d0.png#averageHue=%23f8f6f5&clientId=uf6195e90-5366-4&from=paste&height=380&id=u452ddf31&originHeight=424&originWidth=916&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=29357&status=done&style=none&taskId=u657c70e9-017c-4339-98e0-2d408950262&title=&width=821.0644082234613" alt="image.png"><br>然后再创建一个交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948003779-ea99bac6-6b84-48f3-9760-a719ba5f0c2e.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=359&id=ud456637e&originHeight=401&originWidth=886&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=22862&status=done&style=none&taskId=uba3f2a17-5520-43f0-abd4-2eec22a7c3a&title=&width=794.1736524956187" alt="image.png"><br>然后绑定两个队列到交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947064113-23e123ec-a601-4af4-a44f-70f7b4ef4063.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=527&id=u2d63999d&originHeight=588&originWidth=978&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34267&status=done&style=none&taskId=uc512438d-9693-44f1-9c35-33917ddbced&title=&width=876.6386367276695" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947695506-5346b816-61c7-4bfe-a28d-db261b3598c5.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=537&id=u17bcbe41&originHeight=599&originWidth=985&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34532&status=done&style=none&taskId=u17b49cc4-004f-4e31-bd46-bdef7fe19a1&title=&width=882.9131463974993" alt="image.png"></p><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-消息接收"><a href="#3-5-3-消息接收" class="headerlink" title="3.5.3.消息接收"></a>3.5.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-4-总结"><a href="#3-5-4-总结" class="headerlink" title="3.5.4.总结"></a>3.5.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><h2 id="3-6-Direct交换机"><a href="#3-6-Direct交换机" class="headerlink" title="3.6.Direct交换机"></a>3.6.Direct交换机</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182404437-027a5191-b037-4033-baab-6bafd998161d.png#averageHue=%23fbf5f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=430&id=uf5b6a678&originHeight=533&originWidth=1686&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=93278&status=done&style=none&taskId=ud6ffb209-4207-40a6-a7ab-4977cab3b5d&title=&width=1360.1344101806637" alt="image.png"><br>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如图</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182519270-885589ec-7f4a-492a-ab78-cddf109121cc.png#averageHue=%23fbf6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=430&id=u4dde4f59&originHeight=533&originWidth=1362&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=64401&status=done&style=none&taskId=u62c673b4-a71b-40bf-af49-a8c1a4df0de&title=&width=1098.7562672989704" alt="image.png"></p><ol><li>声明一个名为<code>hmall.direct</code>的交换机</li><li>声明队列<code>direct.queue1</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>blud</code>和<code>red</code></li><li>声明队列<code>direct.queue2</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>yellow</code>和<code>red</code></li><li>在<code>consumer</code>服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2 </li><li>在publisher中编写测试方法，向<code>hmall.direct</code>发送消息</li></ol><h3 id="3-6-1-声明队列和交换机"><a href="#3-6-1-声明队列和交换机" class="headerlink" title="3.6.1.声明队列和交换机"></a>3.6.1.声明队列和交换机</h3><p>首先在控制台声明两个队列<code>direct.queue1</code>和<code>direct.queue2</code>，这里不再展示过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947864231-5ace5d74-fdac-4a2a-9f92-180df06fe4ad.png#averageHue=%23f2f0ef&clientId=uf6195e90-5366-4&from=paste&height=403&id=u292b8851&originHeight=450&originWidth=1157&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=56948&status=done&style=none&taskId=uf110e543-1005-4b1a-b23e-d8529df3c0c&title=&width=1037.0868125704637" alt="image.png"><br>然后声明一个direct类型的交换机，命名为<code>hmall.direct</code>:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948033525-e6ea1134-c2ef-4b80-86b2-b364c1301335.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=367&id=u0964090b&originHeight=409&originWidth=871&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=22938&status=done&style=none&taskId=u127085fa-3898-488f-afef-52a7cbf9e2d&title=&width=780.7282746316974" alt="image.png"><br>然后使用<code>red</code>和<code>blue</code>作为key，绑定<code>direct.queue1</code>到<code>hmall.direct</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948151280-bed1019d-7d60-455b-95b8-754e266edf50.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=523&id=uf5aa7079&originHeight=583&originWidth=942&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=35339&status=done&style=none&taskId=u31d3c033-0a9a-446f-9ebc-a90405ba47d&title=&width=844.3697298542583" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948181033-6b1e6556-0110-4ed8-a2cb-8bc2dd388903.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=522&id=u4e6a2147&originHeight=582&originWidth=874&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34608&status=done&style=none&taskId=u274e41ea-73f2-4da5-bc23-fed091d234d&title=&width=783.4173502044816" alt="image.png"></p><p>同理，使用<code>red</code>和<code>yellow</code>作为key，绑定<code>direct.queue2</code>到<code>hmall.direct</code>，步骤略，最终结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948243879-c97a0e6f-807a-4bc3-ad53-032c378008f3.png#averageHue=%23f4f4f3&clientId=uf6195e90-5366-4&from=paste&height=515&id=ufb0f0d5d&originHeight=575&originWidth=834&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=37957&status=done&style=none&taskId=uaae894e6-bc07-4e01-bf1f-53561ffd05a&title=&width=747.5630092340249" alt="image.png"></p><h3 id="3-6-2-消息接收"><a href="#3-6-2-消息接收" class="headerlink" title="3.6.2.消息接收"></a>3.6.2.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3-消息发送"><a href="#3-6-3-消息发送" class="headerlink" title="3.6.3.消息发送"></a>3.6.3.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用的red这个key，所以两个消费者都收到了消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182883516-906024ce-6ade-4dcd-8b4e-2b0cfc1bd03a.png#averageHue=%23f7f9f3&clientId=u0fe93ba5-a0ba-4&from=paste&height=136&id=uc0e2efee&originHeight=168&originWidth=1410&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=85796&status=done&style=none&taskId=u4ab862c3-bb61-4a97-87d8-ac463218ab2&title=&width=1137.4789551332954" alt="image.png"><br>我们再切换为blue这个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;最新报道，哥斯拉是居民自治巨型气球，虚惊一场！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，只有消费者1收到了消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182898732-afba28a8-c57e-4ccb-a330-9e3315879b31.png#averageHue=%23f7f9f4&clientId=u0fe93ba5-a0ba-4&from=paste&height=175&id=udcac360f&originHeight=217&originWidth=1237&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=99781&status=done&style=none&taskId=ua85a2eca-9806-4a15-997d-ee3c73528b6&title=&width=997.9159343970824" alt="image.png"></p><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h2 id="3-7-Topic交换机"><a href="#3-7-Topic交换机" class="headerlink" title="3.7.Topic交换机"></a>3.7.Topic交换机</h2><h3 id="3-7-1-说明"><a href="#3-7-1-说明" class="headerlink" title="3.7.1.说明"></a>3.7.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。<br>只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>BindingKey</code> 的时候使用通配符！</p><p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如： <code>item.insert</code></p><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p>图示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183148068-ad50ba76-0024-460b-9b24-3cf7a0fe172e.png#averageHue=%23f9f4f3&clientId=u0fe93ba5-a0ba-4&from=paste&height=305&id=u74a65bd0&originHeight=378&originWidth=1337&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=57084&status=done&style=none&taskId=u90f6bfb4-4f10-4ebe-8edb-70856565f27&title=&width=1078.5882007185928" alt="image.png"><br>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</p><ul><li><code>china.news </code>代表有中国的新闻消息；</li><li><code>china.weather</code> 代表中国的天气消息；</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息；</li></ul><p>解释：</p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p>接下来，我们就按照上图所示，来演示一下Topic交换机的用法。<br>首先，在控制台按照图示例子创建队列、交换机，并利用通配符绑定队列和交换机。此处步骤略。最终结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948475987-05bab459-43b6-47ad-bbfc-faf9f50d776e.png#averageHue=%23f5f5f4&clientId=uf6195e90-5366-4&from=paste&height=419&id=u3d545ee6&originHeight=468&originWidth=879&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=32637&status=done&style=none&taskId=u1bf5deb0-6b33-48e6-9d9d-d273a1be805&title=&width=787.8991428257888" alt="image.png"></p><h3 id="3-7-2-消息发送"><a href="#3-7-2-消息发送" class="headerlink" title="3.7.2.消息发送"></a>3.7.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topicExchange</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-3-消息接收"><a href="#3-7-3-消息接收" class="headerlink" title="3.7.3.消息接收"></a>3.7.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-4-总结"><a href="#3-7-4-总结" class="headerlink" title="3.7.4.总结"></a>3.7.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-8-声明队列和交换机"><a href="#3-8-声明队列和交换机" class="headerlink" title="3.8.声明队列和交换机"></a>3.8.声明队列和交换机</h2><p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。<br>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p><h3 id="3-8-1-基本API"><a href="#3-8-1-基本API" class="headerlink" title="3.8.1.基本API"></a>3.8.1.基本API</h3><p>SpringAMQP提供了一个Queue类，用来创建队列：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945200636-5f4a823f-6f36-4088-9b67-7b9b3ae48079.png#averageHue=%23f9fcf7&clientId=uf6195e90-5366-4&from=paste&height=241&id=u2a7bba30&originHeight=269&originWidth=930&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=42392&status=done&style=none&taskId=uf1b5d62e-4e09-4ba8-a011-f8345dac005&title=&width=833.6134275631213" alt="image.png"></p><p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687181804385-c500bc13-9f81-4071-ad8a-598fa5f57d97.png#averageHue=%23f8f8f7&clientId=u0fe93ba5-a0ba-4&from=paste&height=379&id=Qewqz&originHeight=470&originWidth=1469&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=23466&status=done&style=none&taskId=u357861af-c5aa-43c4-aafd-97dadaf8714&title=&width=1185.0755922629864" alt="image.png"><br><img src="/assets/image-20210717165552676.png#id=c2Knj&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945421476-fe44bf9a-d6eb-4f51-af02-374359c8e70b.png#averageHue=%23f8f7f5&clientId=uf6195e90-5366-4&from=paste&height=278&id=uae4334fe&originHeight=310&originWidth=781&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34426&status=done&style=none&taskId=uc1b7bc5b-68b9-4ce9-afe5-9eb733e8f4b&title=&width=700.0560074481696" alt="image.png"><br>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945503733-13d2179c-f586-4de5-b18c-d3b5749f1f96.png#averageHue=%23dcab6a&clientId=uf6195e90-5366-4&from=paste&height=145&id=u91096ccd&originHeight=162&originWidth=659&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=16128&status=done&style=none&taskId=u1da153f0-6e86-45b2-900b-8f83e489358&title=&width=590.7002674882763" alt="image.png"></p><h3 id="3-8-2-fanout示例"><a href="#3-8-2-fanout示例" class="headerlink" title="3.8.2.fanout示例"></a>3.8.2.fanout示例</h3><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hmall.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-2-direct示例"><a href="#3-8-2-direct示例" class="headerlink" title="3.8.2.direct示例"></a>3.8.2.direct示例</h3><p>direct模式由于要绑定多个KEY，会非常麻烦，每一个Key都要编写一个binding：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Direct类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithRed</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithBlue</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithRed</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithYellow</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-8-4-基于注解声明"><a href="#3-8-4-基于注解声明" class="headerlink" title="3.8.4.基于注解声明"></a>3.8.4.基于注解声明</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如，我们同样声明Direct模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是简单多了。<br>再试试Topic模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-消息转换器"><a href="#3-9-消息转换器" class="headerlink" title="3.9.消息转换器"></a>3.9.消息转换器</h2><p>Spring的消息发送代码接收的消息体是一个Object：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183652317-82b0319b-03aa-46ed-afbc-373e7a6fa0f1.png#averageHue=%23f6f9f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=394&id=u2c63fbb1&originHeight=488&originWidth=1448&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=122291&status=done&style=none&taskId=u0da81780-720e-4c27-9c2f-c24d7dc0123&title=&width=1168.1344163354693" alt="image.png"><br>而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-9-1-测试默认转换器"><a href="#3-9-1-测试默认转换器" class="headerlink" title="3.9.1.测试默认转换器"></a>3.9.1.测试默认转换器</h3><p>1）创建测试队列<br>首先，我们在consumer服务中声明一个新的配置类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183868403-242aa812-a07f-4748-8863-dc5d1e161dc1.png#averageHue=%23f9fbf8&clientId=u0fe93ba5-a0ba-4&from=paste&height=351&id=u77b665f4&originHeight=435&originWidth=1053&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48481&status=done&style=none&taskId=uf6d36991-ec76-497c-93d3-3e96d9d6590&title=&width=849.4789643655035" alt="image.png"><br>利用@Bean的方式创建一个队列，<img src="/assets/image-20211104102144275.png#id=PyGPl&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里我们先不要给这个队列添加消费者，我们要查看消息体的格式。</p><p>重启consumer服务以后，该队列就会被自动创建出来了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687184033157-c4c8e59e-a2b3-4b2b-9c20-ca3c597e556c.png#averageHue=%23f3f0ef&clientId=u0fe93ba5-a0ba-4&from=paste&height=456&id=u7c3fdb16&originHeight=565&originWidth=1196&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=72445&status=done&style=none&taskId=u03cddb0f-41a3-483d-83c7-d53a5ecb269&title=&width=964.8403052052632" alt="image.png"><br><img src="/assets/image-20211104102409347.png#id=tPRoz&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>2）发送消息<br>我们在publisher模块的SpringAmqpTest中新增一个消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息后查看控制台：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687184206574-69117533-5b4e-4172-b254-23130023f711.png#averageHue=%23f9f7f7&clientId=u0fe93ba5-a0ba-4&from=paste&height=528&id=u038b25c3&originHeight=654&originWidth=1244&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46749&status=done&style=none&taskId=u8bea522c-fa98-48f1-bd84-1acfb50fff8&title=&width=1003.5629930395882" alt="image.png"><br>可以看到消息格式非常不友好。</p><h3 id="3-9-2-配置JSON转换器"><a href="#3-9-2-配置JSON转换器" class="headerlink" title="3.9.2.配置JSON转换器"></a>3.9.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</p><p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于我们将来做幂等性判断。</p><p>此时，我们到MQ控制台<strong>删除</strong><code>object.queue</code>中的旧的消息。然后再次执行刚才的消息发送的代码，到MQ的控制台查看消息结构：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687245684217-8b401cc5-29e6-4d08-9a9b-4fbe0dffd486.png#averageHue=%23f9f7f7&clientId=ucdd993b6-34bc-4&from=paste&height=432&id=ue5acc96b&originHeight=535&originWidth=990&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=41352&status=done&style=none&taskId=u158a691b-c3b3-4103-993a-3064dc7139b&title=&width=798.655436582952" alt="image.png"><br><img src="/assets/image-20211104102831385.png#id=mx45K&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="3-9-3-消费者接收Object"><a href="#3-9-3-消费者接收Object" class="headerlink" title="3.9.3.消费者接收Object"></a>3.9.3.消费者接收Object</h3><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20211104103017170.png#id=E5J5O&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="4-业务改造"><a href="#4-业务改造" class="headerlink" title="4.业务改造"></a>4.业务改造</h1><p>案例需求：改造余额支付功能，将支付成功后基于OpenFeign的交易服务的更新订单状态接口的同步调用，改为基于RabbitMQ的异步通知。<br>如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690336853591-c874697b-688c-464e-8797-8162a02701e8.png#averageHue=%23faf3f3&clientId=u2c434c61-ffda-4&from=paste&height=396&id=ud83a0c53&originHeight=442&originWidth=1282&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=66835&status=done&style=none&taskId=uac12f07b-6953-4628-933f-82655332fb7&title=&width=1149.1316281031413" alt="image.png"><br>说明，我们只关注交易服务，步骤如下：</p><ul><li>定义topic类型交换机，命名为<code>pay.topic</code></li><li>定义消息队列，命名为<code>mark.order.pay.queue</code></li><li>将<code>mark.order.pay.queue</code>与<code>pay.topic</code>绑定，<code>BindingKey</code>为<code>pay.success</code></li><li>支付成功时不再调用交易服务更新订单状态的接口，而是发送一条消息到<code>pay.topic</code>，发送消息的<code>RoutingKey</code>  为<code>pay.success</code>，消息内容是订单id</li><li>交易服务监听<code>mark.order.pay.queue</code>队列，接收到消息后更新订单状态为已支付</li></ul><h2 id="4-1-配置MQ"><a href="#4-1-配置MQ" class="headerlink" title="4.1.配置MQ"></a>4.1.配置MQ</h2><p>不管是生产者还是消费者，都需要配置MQ的基本信息。分为两步：<br>1）添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息发送--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置MQ地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h2 id="4-1-接收消息"><a href="#4-1-接收消息" class="headerlink" title="4.1.接收消息"></a>4.1.接收消息</h2><p>在trade-service服务中定义一个消息监听类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690339169409-cf6a9ad7-c364-4a26-992d-dd678f53e910.png#averageHue=%23f9fbf8&clientId=u2c434c61-ffda-4&from=paste&height=362&id=uc197e23b&originHeight=404&originWidth=899&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=38311&status=done&style=none&taskId=u11e78c89-237d-4689-a03a-1caed96b8fe&title=&width=805.8263133110172" alt="image.png"><br>其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayStatusListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;mark.order.pay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;pay.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &quot;pay.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenPaySuccess</span><span class="params">(Long orderId)</span>&#123;</span><br><span class="line">        orderService.markOrderPaySuccess(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-发送消息"><a href="#4-2-发送消息" class="headerlink" title="4.2.发送消息"></a>4.2.发送消息</h2><p>修改<code>pay-service</code>服务下的<code>com.hmall.pay.service.impl.PayOrderServiceImpl</code>类中的<code>tryPayOrderByBalance</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderDTO payOrderDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询支付单</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderDTO.getId());</span><br><span class="line">    <span class="comment">// 2.判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus()))&#123;</span><br><span class="line">        <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试扣减余额</span></span><br><span class="line">    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());</span><br><span class="line">    <span class="comment">// 4.修改支付单状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.修改订单状态</span></span><br><span class="line">    <span class="comment">// tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;pay.topic&quot;</span>, <span class="string">&quot;pay.success&quot;</span>, po.getBizOrderNo());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;支付成功的消息发送失败，支付单id：&#123;&#125;， 交易单id：&#123;&#125;&quot;</span>, po.getId(), po.getBizOrderNo(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-练习"><a href="#5-练习" class="headerlink" title="5.练习"></a>5.练习</h1><h2 id="5-1-抽取共享的MQ配置"><a href="#5-1-抽取共享的MQ配置" class="headerlink" title="5.1.抽取共享的MQ配置"></a>5.1.抽取共享的MQ配置</h2><p>将MQ配置抽取到Nacos中管理，微服务中直接使用共享配置。</p><h2 id="5-2-改造下单功能"><a href="#5-2-改造下单功能" class="headerlink" title="5.2.改造下单功能"></a>5.2.改造下单功能</h2><p>改造下单功能，将基于OpenFeign的清理购物车同步调用，改为基于RabbitMQ的异步通知：</p><ul><li>定义topic类型交换机，命名为<code>trade.topic</code></li><li>定义消息队列，命名为<code>cart.clear.queue</code></li><li>将<code>cart.clear.queue</code>与<code>trade.topic</code>绑定，<code>BindingKey</code>为<code>order.create</code></li><li>下单成功时不再调用清理购物车接口，而是发送一条消息到<code>trade.topic</code>，发送消息的<code>RoutingKey</code>  为<code>order.create</code>，消息内容是下单的具体商品、当前登录用户信息</li><li>购物车服务监听<code>cart.clear.queue</code>队列，接收到消息后清理指定用户的购物车中的指定商品</li></ul><h2 id="5-3-登录信息传递优化"><a href="#5-3-登录信息传递优化" class="headerlink" title="5.3.登录信息传递优化"></a>5.3.登录信息传递优化</h2><p>某些业务中，需要根据登录用户信息处理业务，而基于MQ的异步调用并不会传递登录用户信息。前面我们的做法比较麻烦，至少要做两件事：</p><ul><li>消息发送者在消息体中传递登录用户</li><li>消费者获取消息体中的登录用户，处理业务</li></ul><p>这样做不仅麻烦，而且编程体验也不统一，毕竟我们之前都是使用UserContext来获取用户。</p><p>大家思考一下：有没有更优雅的办法传输登录用户信息，让使用MQ的人无感知，依然采用UserContext来随时获取用户。</p><p>参考资料：<br><a href="https://docs.spring.io/spring-amqp/docs/2.4.14/reference/html/#post-processing">Spring AMQP</a></p><h2 id="5-4-改造项目一"><a href="#5-4-改造项目一" class="headerlink" title="5.4.改造项目一"></a>5.4.改造项目一</h2><p>思考一下，项目一中的哪些业务可以由同步方式改为异步方式调用？试着改造一下。<br>举例：短信发送</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
